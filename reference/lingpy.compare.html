
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>lingpy.compare package &#8212; LingPy</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/lingpy.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<link rel="stylesheet" type="text/css" href="_static/handheld.css" media="screen and (max-device-width: 720px)" />
<style>
li.nav-item{display: None!important};
</style>

  </head><body>
<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
LingPy
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
  <li><a href="../download.html">Download</a></li>

        <li class="nav-item nav-item-this"><a href="">lingpy.compare package</a></li> 
      </ul>
    </div>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="lingpy-compare-package">
<h1>lingpy.compare package<a class="headerlink" href="#lingpy-compare-package" title="Permalink to this headline">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-lingpy.compare.lexstat">
<span id="lingpy-compare-lexstat-module"></span><h2>lingpy.compare.lexstat module<a class="headerlink" href="#module-lingpy.compare.lexstat" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.LexStat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lingpy.compare.lexstat.</span></span><span class="sig-name descname"><span class="pre">LexStat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.LexStat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingpy.basic.html#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingpy.basic.wordlist.Wordlist</span></code></a></p>
<p>Basic class for automatic cognate detection.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> : str</p>
<blockquote>
<div><p>The name of the file that shall be loaded.</p>
</div></blockquote>
<p><strong>model</strong> : <a class="reference internal" href="lingpy.data.html#lingpy.data.model.Model" title="lingpy.data.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a></p>
<blockquote>
<div><p>The sound-class model that shall be used for the analysis. Defaults to
the SCA sound-class model.</p>
</div></blockquote>
<p><strong>merge_vowels</strong> : bool (default=True)</p>
<blockquote>
<div><p>Indicate whether consecutive vowels should be merged into single
tokens or kept apart as separate tokens.</p>
</div></blockquote>
<p><strong>transform</strong> : dict</p>
<blockquote>
<div><p>A dictionary that indicates how prosodic strings should be simplified
(or generally transformed), using a simple key-value structure with the
key referring to the original prosodic context and the value to the new
value.
Currently, prosodic strings (see
<a class="reference internal" href="lingpy.sequence.html#lingpy.sequence.sound_classes.prosodic_string" title="lingpy.sequence.sound_classes.prosodic_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prosodic_string()</span></code></a>) offer 11
different prosodic contexts. Since not all these are helpful in
preliminary analyses for cognate detection, it is useful to merge some
of these contexts into one. The default settings distinguish only 5
instead of 11 available contexts, namely:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code> for all consonants in prosodically ascending position,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code> for all consonants in prosodically descending position,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code> for all vowels,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> for all tones, and</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span></code> for word-breaks.</p></li>
</ul>
<p>Make sure to check also the “vowel” keyword when initialising a LexStat
object, since the symbols you use for vowels and tones should be
identical with the ones you define in your transform dictionary.</p>
</div></blockquote>
<p><strong>vowels</strong> : str (default=”<a href="#id1"><span class="problematic" id="id2">VT_</span></a>”)</p>
<blockquote>
<div><p>For scoring function creation using the
<a class="reference internal" href="#lingpy.compare.lexstat.LexStat.get_scorer" title="lingpy.compare.lexstat.LexStat.get_scorer"><code class="xref py py-class docutils literal notranslate"><span class="pre">get_scorer</span></code></a> function, you
have the possibility to use reduced scores for the matching of tones
and vowels by modifying the “vscale” parameter, which is set to 0.5 as
a default.  In order to make sure that vowels and tones are properly
detected, make sure your prosodic string representation of vowels
matches the one in this keyword. Thus, if you change the prosodic
strings using the “transform” keyword, you also need to change the
vowel string, to make sure that “vscale” works as wanted in the
<a class="reference internal" href="#lingpy.compare.lexstat.LexStat.get_scorer" title="lingpy.compare.lexstat.LexStat.get_scorer"><code class="xref py py-class docutils literal notranslate"><span class="pre">get_scorer</span></code></a> function.</p>
</div></blockquote>
<p><strong>check</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to <strong>True</strong>, the input file will first be checked for errors
before the calculation is carried out. Errors will be written to the
file <strong>errors</strong>, defaulting to <code class="docutils literal notranslate"><span class="pre">errors.log</span></code>. See also
<code class="docutils literal notranslate"><span class="pre">apply_checks</span></code> apply_checks : bool (default=False)
If set to <strong>True</strong>, any errors identified by <cite>check</cite> will be handled
silently.</p>
</div></blockquote>
<p><strong>no_bscorer: bool (default=False)</strong> :</p>
<blockquote>
<div><p>If set to <strong>True</strong>, this will suppress the creation of a
language-specific scoring function (which may become quite large and is
additional ballast if the method “lexstat” is not used after all. If
you use the “lexstat” method, however, this needs to be set to
<strong>False</strong>.</p>
</div></blockquote>
<p><strong>errors</strong> : str</p>
<blockquote>
<div><p>The name of the error log.</p>
</div></blockquote>
<p><strong>segments</strong> : str (default=”tokens”)</p>
<blockquote>
<div><p>The name of the column in your data which contains the segmented
transcriptions, or in which the segmented transcriptions should be
placed.</p>
</div></blockquote>
<p><strong>transcription</strong> : str (default=”ipa”)</p>
<blockquote>
<div><p>The name of the column in your data which contains the unsegmented
transcriptions.</p>
</div></blockquote>
<p><strong>classes</strong> : str (default=”classes”)</p>
<blockquote>
<div><p>The name of the column in the data which contains the sound class
representation of the transcriptions, or in which this information
shall be placed after automatic conversion.</p>
</div></blockquote>
<p><strong>numbers</strong> : str (default=”numbers”)</p>
<blockquote>
<div><p>The language-specific triples consisting of language id (numeric),
sound class string (one character only), and prosodic string (one
character only). Usually, numbers are automatically created from
the columns “classes”, “prostrings”, and “langid”, but you can also
provide them in your data.</p>
</div></blockquote>
<p><strong>langid</strong> : str (default=”langid”)</p>
<blockquote>
<div><p>Name of the column that contains a numerical language identifier,
needed to produce the language-specific character triples (“numbers”).
Unless specific explicitly, this is automatically created.</p>
</div></blockquote>
<p><strong>prostrings</strong> : str (default=”prostrings”)</p>
<blockquote>
<div><p>Name of the column containing prosodic strings (see <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2014d"><span class="pre">List2014d</span></a></code>
for more details) of the segmented transcriptions, containing one
character per prosodic string.  Prostrings add a contextual component
to phonetic sequences. They are automatically created, but can likewise
be submitted from the initial data.</p>
</div></blockquote>
<p><strong>weights</strong> : str (default=”weights”)</p>
<blockquote>
<div><p>The name of the column which stores the individual gap-weights for each
sequence. Gap weights are positive floats for each segment in a string,
which modify the gap opening penalty during alignment.</p>
</div></blockquote>
<p><strong>tokenize</strong> : function (default=ipa2tokens)</p>
<blockquote>
<div><p>The function which should be used to tokenize the entries in the column
storing the transcriptions in case no segmentation is provided by the
user.</p>
</div></blockquote>
<p><strong>get_prostring</strong> : function (default=prosodic_string)</p>
<blockquote>
<div><p>The function which should be used to create prosodic strings from the
segmented transcription data. If you want to completely ignore prosodic
strings in LexStat calculations, you could just pass the following
function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lex</span> <span class="o">=</span> <span class="n">LexStat</span><span class="p">(</span><span class="s1">&#39;inputfile.tsv&#39;</span><span class="p">,</span> <span class="n">get_prostring</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="k">for</span>
<span class="go">    y in x])</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>cldf</strong> : bool (default=True)</p>
<blockquote>
<div><p>If set to True, as by default, this will allow for a specific treatment
of phonetic
symbols which cannot be completely resolved when internally
converting tokens to classes (e.g., laryngeal h₂ in
Indo-European). Following the <a class="reference external" href="http://cldf.clld.org">CLDF</a>
specifications (in particular the
specifications for writing transcriptions in segmented strings, as
employed by the <a class="reference external" href="http://calc.digling.org/clts/">CLTS</a> initiative), in
cases of insecurity of pronunciation, users can adopt a
<code class="docutils literal notranslate"><span class="pre">`source/target`</span></code> style, where the source is the symbol used, e.g.,
in a reconstruction system, and the target is a proposed phonetic
interpretation. This practice is also accepted by the <a class="reference external" href="http://edictor.digling.org">EDICTOR</a> tool.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Instantiating this class does not require a lot of parameters. However,
the user may modify its behaviour by providing additional attributes in the
input file.</p>
<p class="rubric">Attributes</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 5%" />
<col style="width: 32%" />
<col style="width: 63%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>pairs</p></td>
<td><p>dict</p></td>
<td><p>A dictionary with tuples of language names as key and indices as value,
pointing to unique combinations of words with the same meaning in all
language pairs.</p></td>
</tr>
<tr class="row-even"><td><p>model</p></td>
<td><p><a class="reference internal" href="lingpy.data.html#lingpy.data.model.Model" title="lingpy.data.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a></p></td>
<td><p>The sound class model instance which serves to convert the phonetic
data into sound classes.</p></td>
</tr>
<tr class="row-odd"><td><p>chars</p></td>
<td><p>list</p></td>
<td><p>A list of all unique language-specific character types in the
instantiated LexStat object. The characters in this list consist of</p>
<ul class="simple">
<li><p>the language identifier (numeric, referenced as “langid” as a
default, but customizable via the keyword “langid”)</p></li>
<li><p>the sound class symbol for the respective IPA transcription value</p></li>
<li><p>the prosodic class value</p></li>
</ul>
<p>All values are represented in the above order as one string, separated
by a dot. Gaps are also included in this collection. They are
traditionally represented as “X” for the sound class and “-” for the
prosodic string.</p>
</td>
</tr>
<tr class="row-even"><td><p>rchars</p></td>
<td><p>list</p></td>
<td><p>A list containing all unique character types across languages. In
contrast to the chars-attribute, the “rchars” (raw chars) do not
contain the language identifier, thus they only consist of two values,
separated by a dot, namely, the sound class symbol, and the prosodic
class value.</p></td>
</tr>
<tr class="row-odd"><td><p>scorer</p></td>
<td><p>dict</p></td>
<td><p>A collection of <code class="xref py py-class docutils literal notranslate"><span class="pre">ScoreDict</span></code>
objects, which are used to score the strings. LexStat distinguishes
two different scoring functions:</p>
<ul class="simple">
<li><p>rscorer: A “raw” scorer that is not language-specific and consists
only of sound class values and prosodic string values. This scorer is
traditionally used to carry out the first alignment in order to
calculate the language-specific scorer. It is directly accessible as
an attribute of the LexStat class
(<code class="xref py py-class docutils literal notranslate"><span class="pre">rscorer</span></code>). The characters
which constitute the values in this scorer are accessible via the
“rchars” attribue of each lexstat class.</p></li>
<li><p>bscorer: The language-specific scorer. This scorer is made of unique
language-specific characters. These are accessible via the “chars”
attribute of each LexStat class. As the “rscorer”, the “bscorer” can
also be accessed directly as an attribute of the LexStat class
(<code class="xref py py-class docutils literal notranslate"><span class="pre">bscorer</span></code>).</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.LexStat.align_pairs">
<span class="sig-name descname"><span class="pre">align_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idxA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idxB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concept</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.LexStat.align_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Align all or some words of a given pair of languages.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>idxA,idxB</strong> : {int, str}</p>
<blockquote>
<div><p>Use an integer to refer to the words by their unique internal ID,
use language names to select all words for a given language.</p>
</div></blockquote>
<p><strong>method</strong> : {‘lexstat’,’sca’}</p>
<blockquote>
<div><p>Define the method to be used for the alignment of the words.</p>
</div></blockquote>
<p><strong>mode</strong> : {‘global’,’local’,’overlap’,’dialign’} (default=’overlap’)</p>
<blockquote>
<div><p>Select the mode for the alignment analysis.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-2)</p>
<blockquote>
<div><p>If ‘sca’ is selected as a method, define the gap opening penalty.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>Select the scale for the gap extension penalty.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>Select the factor for extra scores for identical prosodic segments.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : str (default=”<a href="#id3"><span class="problematic" id="id4">T_</span></a>”)</p>
<blockquote>
<div><p>Select the restricted chars (boundary markers) in the prosodic
strings in order to enable secondary alignment.</p>
</div></blockquote>
<p><strong>distance</strong> : bool (default=True)</p>
<blockquote>
<div><p>If set to c{True}, return the distance instead of the similarity
score.</p>
</div></blockquote>
<p><strong>pprint</strong> : bool (default=True)</p>
<blockquote>
<div><p>If set to c{True}, print the results to the terminal.</p>
</div></blockquote>
<p><strong>return_distance</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return the distance score, otherwise, nothing
will be returned.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.LexStat.cluster">
<span class="sig-name descname"><span class="pre">cluster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sca'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'upgma'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restricted_chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'_T'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'overlap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restriction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.LexStat.cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for flat clustering of words into cognate sets.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> : {‘sca’,’lexstat’,’edit-dist’,’turchin’} (default=’sca’)</p>
<blockquote>
<div><p>Select the method that shall be used for the calculation.</p>
</div></blockquote>
<p><strong>cluster_method</strong> : {‘upgma’,’single’,’complete’, ‘mcl’} (default=’upgma’)</p>
<blockquote>
<div><p>Select the cluster method. ‘upgma’ (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></code>) refers to
average linkage clustering, ‘mcl’ refers to the “Markov Clustering
Algorithm” (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dongen2000"><span class="pre">Dongen2000</span></a></code>).</p>
</div></blockquote>
<p><strong>threshold</strong> : float (default=0.3)</p>
<blockquote>
<div><p>Select the threshold for the cluster approach. If set to c{False},
an automatic threshold will be calculated by calculating the
average distance of unrelated sequences (use with care).</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>Select the scale for the gap extension penalty.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>Select the factor for extra scores for identical prosodic segments.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : str (default=”<a href="#id5"><span class="problematic" id="id6">T_</span></a>”)</p>
<blockquote>
<div><p>Select the restricted chars (boundary markers) in the prosodic
strings in order to enable secondary alignment.</p>
</div></blockquote>
<p><strong>mode</strong> : {‘global’,’local’,’overlap’,’dialign’} (default=’overlap’)</p>
<blockquote>
<div><p>Select the mode for the alignment analysis.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool (default=False)</p>
<blockquote>
<div><p>Define whether verbose output should be used or not.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-2)</p>
<blockquote>
<div><p>If ‘sca’ is selected as a method, define the gap opening penalty.</p>
</div></blockquote>
<p><strong>restriction</strong> : {‘cv’} (default=””)</p>
<blockquote>
<div><p>Specify the restriction for calculations using the edit-distance.
Currently, only “cv” is supported. If <em>edit-dist</em> is selected as
<em>method</em> and <em>restriction</em> is set to <em>cv</em>, consonant-vowel matches
will be prohibited in the calculations and the edit distance will
be normalized by the length of the alignment rather than the length
of the longest sequence, as described in <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Heeringa2006"><span class="pre">Heeringa2006</span></a></code>.</p>
</div></blockquote>
<p><strong>inflation</strong> : {int, float} (default=2)</p>
<blockquote>
<div><p>Specify the inflation parameter for the use of the MCL algorithm.</p>
</div></blockquote>
<p><strong>expansion</strong> : int (default=2)</p>
<blockquote>
<div><p>Specify the expansion parameter for the use of the MCL algorithm.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.LexStat.get_distances">
<span class="sig-name descname"><span class="pre">get_distances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sca'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'overlap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restricted_chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'T_'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.LexStat.get_distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Method calculates different distance estimates for language pairs.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> : {‘sca’,’lexstat’,’edit-dist’,’turchin’} (default=’sca’)</p>
<blockquote>
<div><p>Select the method that shall be used for the calculation.</p>
</div></blockquote>
<p><strong>runs</strong> : int (default=100)</p>
<blockquote>
<div><p>Select the number of random alignments for each language pair.</p>
</div></blockquote>
<p><strong>mode</strong> : {‘global’,’local’,’overlap’,’dialign’} (default=’overlap’)</p>
<blockquote>
<div><p>Select the mode for the alignment analysis.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-2)</p>
<blockquote>
<div><p>If ‘sca’ is selected as a method, define the gap opening penalty.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>Select the scale for the gap extension penalty.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>Select the factor for extra scores for identical prosodic segments.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : str (default=”<a href="#id7"><span class="problematic" id="id8">T_</span></a>”)</p>
<blockquote>
<div><p>Select the restricted chars (boundary markers) in the prosodic
strings in order to enable secondary alignment.</p>
</div></blockquote>
<p><strong>aggregate</strong> : bool (default=True)</p>
<blockquote>
<div><p>Return aggregated distances in form of a distance matrix for all
taxa in the data.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>D</strong> : c{numpy.array}</p>
<blockquote>
<div><p>An array with all distances calculated for each sequence pair.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.LexStat.get_frequencies">
<span class="sig-name descname"><span class="pre">get_frequencies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ftype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sounds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tokens'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.LexStat.get_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the frequencies of a given wordlist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ftype: str (default=’sounds’)</strong> :</p>
<blockquote>
<div><p>The type of frequency which shall be calculated. Select between
“sounds” (type-token frequencies of sounds), and “wordlength”
(average word length per taxon or in aggregated form), or
“diversity” for the diversity index (requires that you have carried
out cognate judgments, and make sure to set the “ref” keyword to
the column in which your cognates are).</p>
</div></blockquote>
<p><strong>ref</strong> : str (default=”tokens”)</p>
<blockquote>
<div><p>The reference column, with the column for “tokens” as a default.
Make sure to modify this keyword in case you want to check for the
“diversity”.</p>
</div></blockquote>
<p><strong>aggregated</strong> : bool (default=False)</p>
<blockquote>
<div><p>Determine whether frequencies should be calculated in an aggregated
way, for all languages, or on a language-per-language basis.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>freqs</strong> : {dict, float}</p>
<blockquote>
<div><p>Depending on the selection of the datatype you chose, this returns
either a dictionary containing the frequencies or a float
indicating the ratio.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.LexStat.get_random_distances">
<span class="sig-name descname"><span class="pre">get_random_distances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lexstat'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">runs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'overlap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restricted_chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'T_'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.LexStat.get_random_distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Method calculates randoms scores for unrelated words in a dataset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> : {‘sca’,’lexstat’,’edit-dist’,’turchin’} (default=’sca’)</p>
<blockquote>
<div><p>Select the method that shall be used for the calculation.</p>
</div></blockquote>
<p><strong>runs</strong> : int (default=100)</p>
<blockquote>
<div><p>Select the number of random alignments for each language pair.</p>
</div></blockquote>
<p><strong>mode</strong> : {‘global’,’local’,’overlap’,’dialign’} (default=’overlap’)</p>
<blockquote>
<div><p>Select the mode for the alignment analysis.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-2)</p>
<blockquote>
<div><p>If ‘sca’ is selected as a method, define the gap opening penalty.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>Select the scale for the gap extension penalty.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>Select the factor for extra scores for identical prosodic segments.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : str (default=”<a href="#id9"><span class="problematic" id="id10">T_</span></a>”)</p>
<blockquote>
<div><p>Select the restricted chars (boundary markers) in the prosodic
strings in order to enable secondary alignment.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>D</strong> : c{numpy.array}</p>
<blockquote>
<div><p>An array with all distances calculated for each sequence pair.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.LexStat.get_scorer">
<span class="sig-name descname"><span class="pre">get_scorer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.LexStat.get_scorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a scoring function based on sound correspondences.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> : str (default=’shuffle’)</p>
<blockquote>
<div><p>Select between “markov”, for automatically generated random
strings, and “shuffle”, for random strings taken directly from the
data.</p>
</div></blockquote>
<p><strong>ratio</strong> : tuple (default=3,2)</p>
<blockquote>
<div><p>Define the ratio between derived and original score for
sound-matches.</p>
</div></blockquote>
<p><strong>vscale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>Define a scaling factor for vowels, in order to decrease their
score in the calculations.</p>
</div></blockquote>
<p><strong>runs</strong> : int (default=1000)</p>
<blockquote>
<div><p>Choose the number of random runs that shall be made in order to
derive the random distribution.</p>
</div></blockquote>
<p><strong>threshold</strong> : float (default=0.7)</p>
<blockquote>
<div><p>The threshold which used to select those words that are compared
in order to derive the attested distribution.</p>
</div></blockquote>
<p><strong>modes</strong> : list (default = [(“global”,-2,0.5),(“local”,-1,0.5)])</p>
<blockquote>
<div><p>The modes which are used in order to derive the distributions from
pairwise alignments.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The scaling factor for sound segments with identical prosodic
environment.</p>
</div></blockquote>
<p><strong>force</strong> : bool (default=False)</p>
<blockquote>
<div><p>Force recalculation of existing distribution.</p>
</div></blockquote>
<p><strong>preprocessing: bool (default=False)</strong> :</p>
<blockquote>
<div><p>Select whether SCA-analysis shall be used to derive a preliminary
set of cognates from which the attested distribution shall be
derived.</p>
</div></blockquote>
<p><strong>rands</strong> : int (default=1000)</p>
<blockquote>
<div><p>If “method” is set to “markov”, this parameter defines the number
of strings to produce for the calculation of the random
distribution.</p>
</div></blockquote>
<p><strong>limit</strong> : int (default=10000)</p>
<blockquote>
<div><p>If “method” is set to “markov”, this parameter defines the limit
above which no more search for unique strings will be carried out.</p>
</div></blockquote>
<p><strong>cluster_method</strong> : {“upgma” “single” “complete”} (default=”upgma”)</p>
<blockquote>
<div><p>Select the method to be used for the calculation of cognates in the
preprocessing phase, if “preprocessing” is set to c{True}.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-2)</p>
<blockquote>
<div><p>If “preprocessing” is selected, define the gap opening penalty for
the preprocessing calculation of cognates.</p>
</div></blockquote>
<p><strong>unattested</strong> : {int, float} (default=-5)</p>
<blockquote>
<div><p>If a pair of sounds is not attested in the data, but expected by
the alignment algorithm that computes the expected distribution,
the score would be -infinity. Yet in order to allow to smooth this
behaviour and to reduce the strictness, we set a default negative
value which does not necessarily need to be too high, since it may
well be that we miss a potentially good pairing in the first runs
of alignment analyses. Use this keyword to adjust this parameter.</p>
</div></blockquote>
<p><strong>unexpected</strong> : {int, float} (default=0.000001)</p>
<blockquote>
<div><p>If a pair is encountered in a given alignment but not expected
according to the randomized alignments, the score would be not
calculable, since we had to divide by zero. For this reason, we set
a very small constant, by which the score is divided in this case.
Not that this constant is only relevant in those cases where the
shuffling procedure was not carried out long enough.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.LexStat.get_subset">
<span class="sig-name descname"><span class="pre">get_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sublist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'concept'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.LexStat.get_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Function creates a specific subset of all word pairs.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sublist</strong> : list</p>
<blockquote>
<div><p>A list which contains those items which should be considered for
the subset creation, for example, a list of concepts.</p>
</div></blockquote>
<p><strong>ref</strong> : string (default=”concept”)</p>
<blockquote>
<div><p>The reference point to compare the given sublist.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function can be used to consider only a smaller part of word pairs
when creating a scorer. Normally, all words are compared, but defining
a subset allows to compare only those belonging to a specific concept
list (Swadesh list).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.LexStat.output">
<span class="sig-name descname"><span class="pre">output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileformat</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.LexStat.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to file.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fileformat</strong> : {‘tsv’, ‘tre’,’nwk’,’dst’, ‘taxa’,’starling’,                 ‘paps.nex’, ‘paps.csv’}</p>
<blockquote>
<div><p>The format that is written to file. This corresponds to the file
extension, thus ‘tsv’ creates a file in tsv-format, ‘dst’ creates
a file in Phylip-distance format, etc.</p>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>Specify the name of the output file (defaults to a filename that
indicates the creation date).</p>
</div></blockquote>
<p><strong>subset</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return only a subset of the data. Which subset
is specified in the keywords ‘cols’ and ‘rows’.</p>
</div></blockquote>
<p><strong>cols</strong> : list</p>
<blockquote>
<div><p>If <em>subset</em> is set to c{True}, specify the columns that shall be
written to the csv-file.</p>
</div></blockquote>
<p><strong>rows</strong> : dict</p>
<blockquote>
<div><p>If <em>subset</em> is set to c{True}, use a dictionary consisting of keys
that specify a column and values that give a Python-statement in
raw text, such as, e.g., “== ‘hand’”. The content of the specified
column will then be checked against statement passed in the
dictionary, and if it is evaluated to c{True}, the respective row
will be written to file.</p>
</div></blockquote>
<p><strong>ref</strong> : str</p>
<blockquote>
<div><p>Name of the column that contains the cognate IDs if ‘starling’ is
chosen as an output format.</p>
</div></blockquote>
<p><strong>missing</strong> : { str, int } (default=0)</p>
<blockquote>
<div><p>If ‘paps.nex’ or ‘paps.csv’ is chosen as fileformat, this character
will be inserted as an indicator of missing data.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : {‘neighbor’, ‘upgma’}</p>
<blockquote>
<div><p>If no tree has been calculated and ‘tre’ or ‘nwk’ is chosen as
output format, the method that is used to calculate the tree.</p>
</div></blockquote>
<p><strong>threshold</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The threshold that is used to carry out a flat cluster analysis if
‘groups’ or ‘cluster’ is chosen as output format.</p>
</div></blockquote>
<p><strong>ignore</strong> : { list, “all” }</p>
<blockquote>
<div><p>Modifies the output format in “tsv” output and allows to ignore
certain blocks in extended “tsv”, like “msa”, “taxa”, “json”, etc.,
which should be passed as a list. If you choose “all” as a plain
string and not a list, this will ignore all additional blocks and
output only plain “tsv”.</p>
</div></blockquote>
<p><strong>prettify</strong> : bool (default=True)</p>
<blockquote>
<div><p>Inserts comment characters between concepts in the “tsv” file
output format, which makes it easier to see blocks of words
denoting the same concept. Switching this off will output the file
in plain “tsv”.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.char_from_charstring">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.lexstat.</span></span><span class="sig-name descname"><span class="pre">char_from_charstring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cstring</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.char_from_charstring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.lexstat.get_score_dict">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.lexstat.</span></span><span class="sig-name descname"><span class="pre">get_score_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.lexstat.get_score_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-lingpy.compare.partial">
<span id="lingpy-compare-partial-module"></span><h2>lingpy.compare.partial module<a class="headerlink" href="#module-lingpy.compare.partial" title="Permalink to this headline">¶</a></h2>
<p>Module provides a class for partial cognate detection, expanding the LexStat class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="lingpy.compare.partial.Partial">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lingpy.compare.partial.</span></span><span class="sig-name descname"><span class="pre">Partial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">infile</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.partial.Partial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.compare.lexstat.LexStat" title="lingpy.compare.lexstat.LexStat"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingpy.compare.lexstat.LexStat</span></code></a></p>
<p>Extended class for automatic detection of partial cognates.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> : str</p>
<blockquote>
<div><p>The name of the file that shall be loaded.</p>
</div></blockquote>
<p><strong>model</strong> : <a class="reference internal" href="lingpy.data.html#lingpy.data.model.Model" title="lingpy.data.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a></p>
<blockquote>
<div><p>The sound-class model that shall be used for the analysis. Defaults to
the SCA sound-class model.</p>
</div></blockquote>
<p><strong>merge_vowels</strong> : bool (default=True)</p>
<blockquote>
<div><p>Indicate whether consecutive vowels should be merged into single tokens or kept
apart as separate tokens.</p>
</div></blockquote>
<p><strong>transform</strong> : dict</p>
<blockquote>
<div><p>A dictionary that indicates how prosodic strings should be simplified
(or generally transformed), using a simple key-value structure with the
key referring to the original prosodic context and the value to the new
value.  Currently, prosodic strings (see
<a class="reference internal" href="lingpy.sequence.html#lingpy.sequence.sound_classes.prosodic_string" title="lingpy.sequence.sound_classes.prosodic_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prosodic_string()</span></code></a>) offer 11
different prosodic contexts. Since not all these are helpful in
preliminary analyses for cognate detection, it is useful to merge
some of these contexts into one. The default settings distinguish only
5 instead of 11 available contexts, namely:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code> for all consonants in prosodically ascending position,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code> for all consonants in prosodically descending position,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code> for all vowels,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> for all tones, and</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span></code> for word-breaks.</p></li>
</ul>
<p>Make sure to check also the “vowel” keyword when initialising a LexStat
object, since the symbols you use for vowels and tones should be
identical with the ones you define in your transform dictionary.</p>
</div></blockquote>
<p><strong>vowels</strong> : str (default=”<a href="#id11"><span class="problematic" id="id12">VT_</span></a>”)</p>
<blockquote>
<div><p>For scoring function creation using the
<a class="reference internal" href="#lingpy.compare.lexstat.LexStat.get_scorer" title="lingpy.compare.lexstat.LexStat.get_scorer"><code class="xref py py-class docutils literal notranslate"><span class="pre">get_scorer</span></code></a> function, you
have the possibility to use reduced scores for the matching of tones
and vowels by modifying the “vscale” parameter, which is set to 0.5 as
a default.  In order to make sure that vowels and tones are properly
detected, make sure your prosodic string representation of vowels
matches the one in this keyword. Thus, if you change the prosodic
strings using the “transform” keyword, you also need to change the
vowel string, to make sure that “vscale” works as wanted in the
<a class="reference internal" href="#lingpy.compare.lexstat.LexStat.get_scorer" title="lingpy.compare.lexstat.LexStat.get_scorer"><code class="xref py py-class docutils literal notranslate"><span class="pre">get_scorer</span></code></a> function.</p>
</div></blockquote>
<p><strong>check</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to <strong>True</strong>, the input file will first be checked for errors
before the calculation is carried out. Errors will be written to the
file <strong>errors</strong>, defaulting to <code class="docutils literal notranslate"><span class="pre">errors.log</span></code>. See also <code class="docutils literal notranslate"><span class="pre">apply_checks</span></code></p>
</div></blockquote>
<p><strong>apply_checks</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to <strong>True</strong>, any errors identified by <cite>check</cite> will be handled
silently.</p>
</div></blockquote>
<p><strong>no_bscorer: bool (default=False)</strong> :</p>
<blockquote>
<div><p>If set to <strong>True</strong>, this will suppress the creation of a
language-specific scoring function (which may become quite large and is
additional ballast if the method “lexstat” is not used after all. If
you use the “lexstat” method, however, this needs to be set to
<strong>False</strong>.</p>
</div></blockquote>
<p><strong>errors</strong> : str</p>
<blockquote>
<div><p>The name of the error log.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method automatically infers partial cognate sets from data which was
previously morphologically segmented.</p>
<p class="rubric">Attributes</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 3%" />
<col style="width: 17%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>pairs</p></td>
<td><p>dict</p></td>
<td><p>A dictionary with tuples of language names as key and indices as value,         pointing to unique combinations of words with the same meaning in all         language pairs.</p></td>
</tr>
<tr class="row-even"><td><p>model</p></td>
<td><p><a class="reference internal" href="lingpy.data.html#lingpy.data.model.Model" title="lingpy.data.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a></p></td>
<td><p>The sound class model instance which serves to convert the phonetic
data into sound classes.</p></td>
</tr>
<tr class="row-odd"><td><p>chars</p></td>
<td><p>list</p></td>
<td><p>A list of all unique language-specific character types in the
instantiated LexStat object. The characters in this list consist of</p>
<ul class="simple">
<li><p>the language identifier (numeric, referenced as “langid” as a
default, but customizable via the keyword “langid”)</p></li>
<li><p>the sound class symbol for the respective IPA transcription value</p></li>
<li><p>the prosodic class value</p></li>
</ul>
<p>All values are represented in the above order as one string, separated
by a dot. Gaps are also included in this collection. They are
traditionally represented as “X” for the sound class and “-” for the
prosodic string.</p>
</td>
</tr>
<tr class="row-even"><td><p>rchars</p></td>
<td><p>list</p></td>
<td><p>A list containing all unique character types across languages. In
contrast to the chars-attribute, the “rchars” (raw chars) do not
contain the language identifier, thus they only consist of two values,
separated by a dot, namely, the sound class symbol, and the prosodic
class value.</p></td>
</tr>
<tr class="row-odd"><td><p>scorer</p></td>
<td><p>dict</p></td>
<td><p>A collection of <code class="xref py py-class docutils literal notranslate"><span class="pre">ScoreDict</span></code>
objects, which are used to score the strings. LexStat distinguishes two
different scoring functions:</p>
<ul class="simple">
<li><p>rscorer: A “raw” scorer that is not language-specific and consists
only of sound class values and prosodic string values. This scorer is
traditionally used to carry out the first alignment in order to
calculate the language-specific scorer. It is directly accessible as an
attribute of the LexStat class
(<code class="xref py py-class docutils literal notranslate"><span class="pre">rscorer</span></code>). The characters
which constitute the values in this scorer are accessible via the
“rchars” attribue of each lexstat class.</p></li>
<li><p>bscorer: The language-specific scorer. This scorer is made of unique
language-specific characters. These are accessible via the “chars”
attribute of each LexStat class. As the “rscorer”, the “bscorer” can
also be accessed directly as an attribute of the LexStat class
(<code class="xref py py-class docutils literal notranslate"><span class="pre">bscorer</span></code>).</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.partial.Partial.add_cognate_ids">
<span class="sig-name descname"><span class="pre">add_cognate_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.partial.Partial.add_cognate_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute normal cognate identifiers from partial cognate sets.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>source: str</strong> :</p>
<blockquote>
<div><p>Name of the source column in your wordlist file.</p>
</div></blockquote>
<p><strong>target</strong> : str</p>
<blockquote>
<div><p>Name of the target column in your wordlist file.</p>
</div></blockquote>
<p><strong>idtype</strong> : str (default=”strict”)</p>
<blockquote>
<div><p>Select between “strict” and “loose”.</p>
</div></blockquote>
<p><strong>override: bool (default=False)</strong> :</p>
<blockquote>
<div><p>Specify whether you want to override existing columns.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>While the computation of strict cognate IDs from partial cognate IDs is
straightforward and just judges those words as cognate which are
identical in all their parts, the computation of loose cognate IDs
constructs a network between all words, draws lines between all words
that share a common morpheme, and judges all connected components in this
network as cognate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.partial.Partial.get_partial_scorer">
<span class="sig-name descname"><span class="pre">get_partial_scorer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.partial.Partial.get_partial_scorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a scoring function based on sound correspondences.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> : str (default=’shuffle’)</p>
<blockquote>
<div><p>Select between “markov”, for automatically generated random
strings, and “shuffle”, for random strings taken directly from the
data.</p>
</div></blockquote>
<p><strong>ratio</strong> : tuple (default=3,2)</p>
<blockquote>
<div><p>Define the ratio between derived and original score for
sound-matches.</p>
</div></blockquote>
<p><strong>vscale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>Define a scaling factor for vowels, in order to decrease their
score in the calculations.</p>
</div></blockquote>
<p><strong>runs</strong> : int (default=1000)</p>
<blockquote>
<div><p>Choose the number of random runs that shall be made in order to
derive the random distribution.</p>
</div></blockquote>
<p><strong>threshold</strong> : float (default=0.7)</p>
<blockquote>
<div><p>The threshold which used to select those words that are compared
in order to derive the attested distribution.</p>
</div></blockquote>
<p><strong>modes</strong> : list (default = [(“global”,-2,0.5),(“local”,-1,0.5)])</p>
<blockquote>
<div><p>The modes which are used in order to derive the distributions from
pairwise alignments.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The scaling factor for sound segments with identical prosodic
environment.</p>
</div></blockquote>
<p><strong>force</strong> : bool (default=False)</p>
<blockquote>
<div><p>Force recalculation of existing distribution.</p>
</div></blockquote>
<p><strong>preprocessing: bool (default=False)</strong> :</p>
<blockquote>
<div><p>Select whether SCA-analysis shall be used to derive a preliminary
set of cognates from which the attested distribution shall be
derived.</p>
</div></blockquote>
<p><strong>rands</strong> : int (default=1000)</p>
<blockquote>
<div><p>If “method” is set to “markov”, this parameter defines the number
of strings to produce for the calculation of the random
distribution.</p>
</div></blockquote>
<p><strong>limit</strong> : int (default=10000)</p>
<blockquote>
<div><p>If “method” is set to “markov”, this parameter defines the limit
above which no more search for unique strings will be carried out.</p>
</div></blockquote>
<p><strong>cluster_method</strong> : {“upgma” “single” “complete”} (default=”upgma”)</p>
<blockquote>
<div><p>Select the method to be used for the calculation of cognates in the
preprocessing phase, if “preprocessing” is set to c{True}.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-2)</p>
<blockquote>
<div><p>If “preprocessing” is selected, define the gap opening penalty for
the preprocessing calculation of cognates.</p>
</div></blockquote>
<p><strong>unattested</strong> : {int, float} (default=-5)</p>
<blockquote>
<div><p>If a pair of sounds is not attested in the data, but expected by
the alignment algorithm that computes the expected distribution,
the score would be -infinity. Yet in order to allow to smooth this
behaviour and to reduce the strictness, we set a default negative
value which does not necessarily need to be too high, since it may
well be that we miss a potentially good pairing in the first runs
of alignment analyses. Use this keyword to adjust this parameter.</p>
</div></blockquote>
<p><strong>unexpected</strong> : {int, float} (default=0.000001)</p>
<blockquote>
<div><p>If a pair is encountered in a given alignment but not expected
according to the randomized alignments, the score would be not
calculable, since we had to divide by zero. For this reason, we set
a very small constant, by which the score is divided in this case.
Not that this constant is only relevant in those cases where the
shuffling procedure was not carried out long enough.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.partial.Partial.partial_cluster">
<span class="sig-name descname"><span class="pre">partial_cluster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sca'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.45</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restricted_chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'_T'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'overlap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'infomap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restriction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_on_tones</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.partial.Partial.partial_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster the words into partial cognate sets.</p>
<p>Function for flat clustering of words into cognate sets.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> : {‘sca’,’lexstat’,’edit-dist’,’turchin’} (default=’sca’)</p>
<blockquote>
<div><p>Select the method that shall be used for the calculation.</p>
</div></blockquote>
<p><strong>cluster_method</strong> : {‘upgma’,’single’,’complete’, ‘mcl’} (default=’upgma’)</p>
<blockquote>
<div><p>Select the cluster method. ‘upgma’ (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></code>) refers to
average linkage clustering, ‘mcl’ refers to the “Markov Clustering
Algorithm” (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dongen2000"><span class="pre">Dongen2000</span></a></code>).</p>
</div></blockquote>
<p><strong>threshold</strong> : float (default=0.3)</p>
<blockquote>
<div><p>Select the threshold for the cluster approach. If set to c{False},
an automatic threshold will be calculated by calculating the
average distance of unrelated sequences (use with care).</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>Select the scale for the gap extension penalty.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>Select the factor for extra scores for identical prosodic segments.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : str (default=”<a href="#id13"><span class="problematic" id="id14">T_</span></a>”)</p>
<blockquote>
<div><p>Select the restricted chars (boundary markers) in the prosodic
strings in order to enable secondary alignment.</p>
</div></blockquote>
<p><strong>mode</strong> : {‘global’,’local’,’overlap’,’dialign’} (default=’overlap’)</p>
<blockquote>
<div><p>Select the mode for the alignment analysis.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool (default=False)</p>
<blockquote>
<div><p>Define whether verbose output should be used or not.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-2)</p>
<blockquote>
<div><p>If ‘sca’ is selected as a method, define the gap opening penalty.</p>
</div></blockquote>
<p><strong>restriction</strong> : {‘cv’} (default=””)</p>
<blockquote>
<div><p>Specify the restriction for calculations using the edit-distance.
Currently, only “cv” is supported. If <em>edit-dist</em> is selected as
<em>method</em> and <em>restriction</em> is set to <em>cv</em>, consonant-vowel matches
will be prohibited in the calculations and the edit distance will
be normalized by the length of the alignment rather than the length
of the longest sequence, as described in <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Heeringa2006"><span class="pre">Heeringa2006</span></a></code>.</p>
</div></blockquote>
<p><strong>inflation</strong> : {int, float} (default=2)</p>
<blockquote>
<div><p>Specify the inflation parameter for the use of the MCL algorithm.</p>
</div></blockquote>
<p><strong>expansion</strong> : int (default=2)</p>
<blockquote>
<div><p>Specify the expansion parameter for the use of the MCL algorithm.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-lingpy.compare.phylogeny">
<span id="lingpy-compare-phylogeny-module"></span><h2>lingpy.compare.phylogeny module<a class="headerlink" href="#module-lingpy.compare.phylogeny" title="Permalink to this headline">¶</a></h2>
<p>Phylogeny-based detection of borrowings in lexicostatistical wordlists.</p>
<dl class="py class">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lingpy.compare.phylogeny.</span></span><span class="sig-name descname"><span class="pre">PhyBo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cogid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'neighbor'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingpy.basic.html#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingpy.basic.wordlist.Wordlist</span></code></a></p>
<p>Basic class for calculations using the TreBor method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dataset</strong> : string</p>
<blockquote>
<div><p>Name of the dataset that shall be analyzed.</p>
</div></blockquote>
<p><strong>tree</strong> : {None, string}</p>
<blockquote>
<div><p>Name of the tree file.</p>
</div></blockquote>
<p><strong>paps</strong> : string (default=”pap”)</p>
<blockquote>
<div><p>Name of the column that stores the specific cognate IDs consisting
of an arbitrary integer key and a key for the concept.</p>
</div></blockquote>
<p><strong>ref</strong> : string (default=”cogid”)</p>
<blockquote>
<div><p>Name of the column that stores the general cognate ids (the
“reference” of the analysis).</p>
</div></blockquote>
<p><strong>tree_calc</strong> : {‘neighbor’,’upgma’} (default=’neighbor’)</p>
<blockquote>
<div><p>Select the algorithm to be used for the tree calculation if no tree is
passed with the file.</p>
</div></blockquote>
<p><strong>missing</strong> : int (default=-1)</p>
<blockquote>
<div><p>Specify how missing data should be handled. If set to -1, missing data
can account for both presence or absence of a cognate set in the given
language. If set to 0, missing data is treated as absence.</p>
</div></blockquote>
<p><strong>degree</strong> : int (default=100)</p>
<blockquote>
<div><p>The degree which is chosen for the projection of the tree layout.</p>
</div></blockquote>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">runs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_gml</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_analysis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_dists</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_mln</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_msn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a full analysis using various parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>runs</strong> : {str list} (default=”default”)</p>
<blockquote>
<div><p>Define a couple of different models to be analyzed. Select between:</p>
<ul class="simple">
<li><p>‘default’: weighted analysis, using parsimony and weights for
gains and losses</p></li>
<li><p>‘topdown’: use the traditional approach by
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Nelson-Sathi2011"><span class="pre">Nelson-Sathi2011</span></a></code></p></li>
<li><p>‘restriction’: use the restriction approach</p></li>
</ul>
<p>You can also define your own mix of models.</p>
</div></blockquote>
<p><strong>usetex</strong> : bool (default=True)</p>
<blockquote>
<div><p>Specify whether you want to use LaTeX to render plots.</p>
</div></blockquote>
<p><strong>mixed</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to c{True}, calculate a mixed model by selecting the best
model for each item separately.</p>
</div></blockquote>
<p><strong>output_gml</strong> : bool (default=False)</p>
<blockquote>
<div><p>Set to c{True} in order to output every gain-loss-scenario in
GML-format.</p>
</div></blockquote>
<p><strong>full_analysis</strong> : bool (default=True)</p>
<blockquote>
<div><p>Specifies whether a full analysis is carried out or not.</p>
</div></blockquote>
<p><strong>plot_mln</strong> : bool (default=True)</p>
<blockquote>
<div><p>Select or unselect output plot for the MLN.</p>
</div></blockquote>
<p><strong>plot_msn</strong> : bool (default=False)</p>
<blockquote>
<div><p>Select or unselect output plot for the MSN.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.get_ACS">
<span class="sig-name descname"><span class="pre">get_ACS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.get_ACS" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the ancestral character states (ACS) for all internal nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.get_AVSD">
<span class="sig-name descname"><span class="pre">get_AVSD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.get_AVSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Function retrieves all pap s for ancestor languages in a given tree.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.get_CVSD">
<span class="sig-name descname"><span class="pre">get_CVSD</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.get_CVSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Contemporary Vocabulary Size Distribution (CVSD).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.get_GLS">
<span class="sig-name descname"><span class="pre">get_GLS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'weighted'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restriction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_gml</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.get_GLS" title="Permalink to this definition">¶</a></dt>
<dd><p>Create gain-loss-scenarios for all non-singleton paps in the data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mode</strong> : string (default=”weighted”)</p>
<blockquote>
<div><p>Select between “weighted”, “restriction” and “topdown”. The three
modes refer to the following frameworks:</p>
<ul class="simple">
<li><p>“weighted” refers to the weighted parsimony framework described in
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2014b"><span class="pre">List2014b</span></a></code> and <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2014a"><span class="pre">List2014a</span></a></code>.
Weights are
specified with help of a ratio for the scoring of gain and loss
events. The ratio can be defined with help of the <em>ratio</em>
keyword.</p></li>
<li><p>“restrictino” refers to a simple method in which only a
specific amount of gain events
is allowed. The maximally allowed number of gain events can be
defined with help of the <em>restriction</em> keyword.</p></li>
<li><p>“topdown” refers to the top-down method outlined in
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dagan2007"><span class="pre">Dagan2007</span></a></code> and first applied to linguistic data in
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Nelson-Sathi2011"><span class="pre">Nelson-Sathi2011</span></a></code>. This method also defines a maximal
number of gain events, but in contrast to the “restriction”
approach, it starts from the top of the tree and stops if the
maximal number of restrictions has been reached. The maximally
allowed number of gain events can, again, be specified with help
of the <em>restriction</em> keyword.</p></li>
</ul>
</div></blockquote>
<p><strong>ratio</strong> : tuple (default=(1,1))</p>
<blockquote>
<div><p>If “weighted” mode is selected, define the ratio between the
weights for gains and losses.</p>
</div></blockquote>
<p><strong>restriction</strong> : int (default=3)</p>
<blockquote>
<div><p>If “restriction” is selected as mode, define the maximal number of
gains.</p>
</div></blockquote>
<p><strong>output_gml</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to c{True}, the decisions for each GLS are stored in a
separate file in GML-format.</p>
</div></blockquote>
<p><strong>tar</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to c{True}, the GML-files will be added to a compressed tar-file.</p>
</div></blockquote>
<p><strong>gpl</strong> : int (default=1)</p>
<blockquote>
<div><p>Specifies the maximal number of gains per lineage. This parameter
specifies how cases should be handled in which a character is first
gained, then lost, and then gained again. By setting this parameter
to 1 (the default setting), such cases are prohibited, since only
one gain per lineage is allowed.</p>
</div></blockquote>
<p><strong>missing_data</strong> : int (default=0)</p>
<blockquote>
<div><p>Currently, we offer two ways to handle missing data. The first case
just treats missing data in the same way in which the absence of a
character is handled and can be evoked by setting this parameter to
0. The second case will treat missing data as either absent or
present characters, based on how well each option coincides with
the overall evolutionary scenario. This behaviour can be evoked by
setting this parameter to -1.</p>
</div></blockquote>
<p><strong>push_gains: bool (default=True)</strong> :</p>
<blockquote>
<div><p>In bottom-up calculations, there will often be multiple scenarios
upon which only one is selected by the method. In order to define
consistent criteria for scenario selection, we follow
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Mirkin2003"><span class="pre">Mirkin2003</span></a></code> in allowing to force the algorithm to prefer
those scenarios in which gains are pushed to the leaves. This
behaviour is handle by this parameter. Setting it to <em>True</em> will
force the algorithm to push gain events to the leaves of the tree.
Setting it to <em>False</em> will force it to prefer those scenarios where
the gains are closer to the root.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.get_IVSD">
<span class="sig-name descname"><span class="pre">get_IVSD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_gml</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leading_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mixed_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evaluation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mwu'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.get_IVSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate VSD on the basis of each item.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.get_MLN">
<span class="sig-name descname"><span class="pre">get_MLN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mr'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.get_MLN" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an Minimal Lateral Network for a given model.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>glm</strong> : str</p>
<blockquote>
<div><p>The dictionary key for the gain-loss-model.</p>
</div></blockquote>
<p><strong>threshold</strong> : int (default=1)</p>
<blockquote>
<div><p>The threshold used to exclude edges.</p>
</div></blockquote>
<p><strong>method</strong> : str (default=’mr’)</p>
<blockquote>
<div><p>Select the method for MLN calculation. Choose between:
* “mr”: majority-rule, multiple links are resolved by selecting</p>
<blockquote>
<div><p>those which occur most frequently</p>
</div></blockquote>
<ul class="simple">
<li><p>“td”: tree-distance, multiple links are resolved by selecting
those which are closest on the tree</p></li>
<li><p>“bc”: betweenness-centrality, multiple links are resolved by
selecting those which have the highest betweenness centrality</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.get_MSN">
<span class="sig-name descname"><span class="pre">get_MSN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deep_nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.get_MSN" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Minimal Spatial Network.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>glm</strong> : str (default=’’)</p>
<blockquote>
<div><p>A string that encodes which model should be plotted.</p>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>The name of the file to which the plot shall be written.</p>
</div></blockquote>
<p><strong>fileformat</strong> : str</p>
<blockquote>
<div><p>The output format of the plot.</p>
</div></blockquote>
<p><strong>threshold</strong> : int (default=1)</p>
<blockquote>
<div><p>The threshold for the minimal amount of shared links that shall be
plotted.</p>
</div></blockquote>
<p><strong>usetex</strong> : bool (default=True)</p>
<blockquote>
<div><p>Specify whether LaTeX shall be used for the plot.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.get_PDC">
<span class="sig-name descname"><span class="pre">get_PDC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.get_PDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Patchily Distributed Cognates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.get_edge">
<span class="sig-name descname"><span class="pre">get_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodeA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodeB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.get_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edge data for a given gain-loss model.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.get_stats">
<span class="sig-name descname"><span class="pre">get_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.get_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate basic statistics for a given gain-loss model.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.plot_ACS">
<span class="sig-name descname"><span class="pre">plot_ACS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.plot_ACS" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a tree in which the node size correlates with the size of the ancestral node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.plot_GLS">
<span class="sig-name descname"><span class="pre">plot_GLS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.plot_GLS" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the inferred scenarios for a given model.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.plot_MLN">
<span class="sig-name descname"><span class="pre">plot_MLN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fileformat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pdf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usetex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taxon_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'taxon_short_labels'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.plot_MLN" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the MLN with help of Matplotlib.</p>
<dl class="simple">
<dt>glm<span class="classifier">str (default=’’)</span></dt><dd><p>Identifier for the gain-loss model that is plotted. Defaults to the
model that had the best scores in terms of probability.</p>
</dd>
<dt>filename<span class="classifier">str (default=’’)</span></dt><dd><p>If no filename is selected, the filename is identical with the
dataset.</p>
</dd>
<dt>fileformat<span class="classifier">{‘svg’,’png’,’jpg’,’pdf’} (default=’pdf’)</span></dt><dd><p>Select the format of the output plot.</p>
</dd>
<dt>threshold<span class="classifier">int (default=1)</span></dt><dd><p>Select the threshold for drawing lateral edges.</p>
</dd>
<dt>usetex<span class="classifier">bool (default=True)</span></dt><dd><p>Specify whether you want to use LaTeX to render plots.</p>
</dd>
<dt>colormap<span class="classifier">{None matplotlib.cm}</span></dt><dd><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.colormap</span></code> instance. If set to c{None}, this
defaults to <code class="xref py py-class docutils literal notranslate"><span class="pre">jet</span></code>.</p>
</dd>
<dt>taxon_labels<span class="classifier">str (default=’taxon.short_labels’)</span></dt><dd><p>Specify the taxon labels that should be included in the plot.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.plot_MLN_3d">
<span class="sig-name descname"><span class="pre">plot_MLN_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fileformat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pdf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usetex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taxon_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'taxon_short_labels'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.plot_MLN_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the MLN with help of Matplotlib in 3d.</p>
<dl class="simple">
<dt>glm<span class="classifier">str (default=’’)</span></dt><dd><p>Identifier for the gain-loss model that is plotted. Defaults to the
model that had the best scores in terms of probability.</p>
</dd>
<dt>filename<span class="classifier">str (default=’’)</span></dt><dd><p>If no filename is selected, the filename is identical with the
dataset.</p>
</dd>
<dt>fileformat<span class="classifier">{‘svg’,’png’,’jpg’,’pdf’} (default=’pdf’)</span></dt><dd><p>Select the format of the output plot.</p>
</dd>
<dt>threshold<span class="classifier">int (default=1)</span></dt><dd><p>Select the threshold for drawing lateral edges.</p>
</dd>
<dt>usetex<span class="classifier">bool (default=True)</span></dt><dd><p>Specify whether you want to use LaTeX to render plots.</p>
</dd>
<dt>colormap<span class="classifier">{None matplotlib.cm}</span></dt><dd><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.colormap</span></code> instance. If set to c{None}, this
defaults to <code class="xref py py-class docutils literal notranslate"><span class="pre">jet</span></code>.</p>
</dd>
<dt>taxon_labels<span class="classifier">str (default=’taxon.short_labels’)</span></dt><dd><p>Specify the taxon labels that should be included in the plot.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.plot_MSN">
<span class="sig-name descname"><span class="pre">plot_MSN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fileformat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pdf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usetex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.plot_MSN" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a minimal spatial network.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.plot_concept_evolution">
<span class="sig-name descname"><span class="pre">plot_concept_evolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concept</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fileformat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'png'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.plot_concept_evolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the evolution of specific concepts along the reference tree.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.PhyBo.plot_two_concepts">
<span class="sig-name descname"><span class="pre">plot_two_concepts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">concept</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cogA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cogB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{1:</span> <span class="pre">'1',</span> <span class="pre">2:</span> <span class="pre">'2',</span> <span class="pre">3:</span> <span class="pre">'3',</span> <span class="pre">4:</span> <span class="pre">'4'}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tcolor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{1:</span> <span class="pre">'white',</span> <span class="pre">2:</span> <span class="pre">'black',</span> <span class="pre">3:</span> <span class="pre">'0.5',</span> <span class="pre">4:</span> <span class="pre">'0.1'}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pdf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fileformat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pdf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usetex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.PhyBo.plot_two_concepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the evolution of two concepts in space.</p>
<p class="rubric">Notes</p>
<p>This function may be useful to contrast patterns of different words in
geographic space.</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.TreBor">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.phylogeny.</span></span><span class="sig-name descname"><span class="pre">TreBor</span></span><a class="headerlink" href="#lingpy.compare.phylogeny.TreBor" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#lingpy.compare.phylogeny.PhyBo" title="lingpy.compare.phylogeny.PhyBo"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingpy.compare.phylogeny.PhyBo</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.phylogeny.get_gls">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.phylogeny.</span></span><span class="sig-name descname"><span class="pre">get_gls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">paps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taxa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gpl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">push_gains</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.phylogeny.get_gls" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a gain-loss scenario.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>paps</strong> : list</p>
<blockquote>
<div><p>A list containing the presence-absence patterns for all leaves of the
reference tree. Presence is indicated by 1, and absence by 0. Missing
characters are indicated by -1.</p>
</div></blockquote>
<p><strong>taxa</strong> : list</p>
<blockquote>
<div><p>The list of taxa (leaves of the tree).</p>
</div></blockquote>
<p><strong>tree</strong> : str</p>
<blockquote>
<div><p>A tree in Newick-format. Taxon names should (of course) be identical
with the names in the list of taxa.</p>
</div></blockquote>
<p><strong>gpl</strong> : int</p>
<blockquote>
<div><p>Gains per lineage. Specify the maximal amount of gains per lineage. One
lineage is hereby defined as one path in the tree. If set to 0, only
one gain per lineage is allowed, if set to 1, one additional gain is
allowed, and so on. Use with care, since this will lead to larger
computation costs (more possibilities have to be taken care of) and can
also be quite unrealistic.</p>
</div></blockquote>
<p><strong>weights</strong> : tuple (default=(1,1))</p>
<blockquote>
<div><p>Specify the weights for gains and losses. Setting this parameter to
(2,1) will penalize gain events with 2 and loss events with 1.</p>
</div></blockquote>
<p><strong>push_gains</strong> : bool (default=True)</p>
<blockquote>
<div><p>Determine whether of a set of equally parsimonious patterns those
should be retained that show gains closer to the leaves of the tree or
not.</p>
</div></blockquote>
<p><strong>missing_data</strong> : int (default=0)</p>
<blockquote>
<div><p>Determine how missing data should be represented. If set to 0
(default), missing data will be treated in the same way as absence
character states. If you want missing data to be accounted for in the
algorithm, set this parameter to -1.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is an enhanced version of the older approach to parsimony-based
gain-loss mapping. The algorithm is much faster than the previous one and
also written much clearer as to the code. In most tests I ran so far, it
also outperformed other approaches by finding more parsimonious solutions.</p>
</dd></dl>

</section>
<section id="module-lingpy.compare.sanity">
<span id="lingpy-compare-sanity-module"></span><h2>lingpy.compare.sanity module<a class="headerlink" href="#module-lingpy.compare.sanity" title="Permalink to this headline">¶</a></h2>
<p>Module provides basic checks for wordlists.</p>
<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.sanity.average_coverage">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.sanity.</span></span><span class="sig-name descname"><span class="pre">average_coverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wordlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concepts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'concepts'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.sanity.average_coverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute average mutual coverage for a given wordlist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wordlist</strong> : ~lingpy.basic.wordlist.Wordlist</p>
<blockquote>
<div><p>Your Wordlist object (or a descendant class).</p>
</div></blockquote>
<p><strong>concepts</strong> : str (default=”concept”)</p>
<blockquote>
<div><p>The column which stores your concepts.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>coverage</strong> : dict</p>
<blockquote>
<div><p>A dictionary of dictionaries whose value is the number of items two
languages share.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#lingpy.compare.sanity.mutual_coverage_check" title="lingpy.compare.sanity.mutual_coverage_check"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutual_coverage_check</span></code></a>, <a class="reference internal" href="#lingpy.compare.sanity.mutual_coverage_subset" title="lingpy.compare.sanity.mutual_coverage_subset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutual_coverage_subset</span></code></a>, <a class="reference internal" href="#lingpy.compare.sanity.mutual_coverage" title="lingpy.compare.sanity.mutual_coverage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutual_coverage</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Compute coverage for the KSL.qlc dataset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.compare.sanity</span> <span class="kn">import</span> <span class="n">average_coverage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.tests.util</span> <span class="kn">import</span> <span class="n">test_data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span> <span class="o">=</span> <span class="n">Wordlist</span><span class="p">(</span><span class="n">test_data</span><span class="p">(</span><span class="s1">&#39;KSL.qlc&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">average_coverage</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.sanity.check_cognates">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.sanity.</span></span><span class="sig-name descname"><span class="pre">check_cognates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wordlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'crossids'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.sanity.check_cognates" title="Permalink to this definition">¶</a></dt>
<dd><p>Function checks for internal consistency of partial cognates.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.sanity.check_length">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.sanity.</span></span><span class="sig-name descname"><span class="pre">check_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.sanity.check_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Custom function to check the length of two basictypes in LingPy.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.sanity.check_sequence_length">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.sanity.</span></span><span class="sig-name descname"><span class="pre">check_sequence_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wordlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entities</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['tokens',</span> <span class="pre">'crossids',</span> <span class="pre">'morphemes',</span> <span class="pre">'structure']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[2,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">1]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.sanity.check_sequence_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Function checks for identical sequence length in different columns.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.sanity.check_strict_cognates">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.sanity.</span></span><span class="sig-name descname"><span class="pre">check_strict_cognates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wordlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'crossids'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tokens'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.sanity.check_strict_cognates" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if cognates are really strict.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.sanity.mutual_coverage">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.sanity.</span></span><span class="sig-name descname"><span class="pre">mutual_coverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wordlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concepts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'concept'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.sanity.mutual_coverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mutual coverage for all language pairs in your data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wordlist</strong> : ~lingpy.basic.wordlist.Wordlist</p>
<blockquote>
<div><p>Your Wordlist object (or a descendant class).</p>
</div></blockquote>
<p><strong>concepts</strong> : str (default=”concept”)</p>
<blockquote>
<div><p>The column which stores your concepts.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>coverage</strong> : dict</p>
<blockquote>
<div><p>A dictionary of dictionaries whose value is the number of items two
languages share.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#lingpy.compare.sanity.mutual_coverage_check" title="lingpy.compare.sanity.mutual_coverage_check"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutual_coverage_check</span></code></a>, <a class="reference internal" href="#lingpy.compare.sanity.mutual_coverage_subset" title="lingpy.compare.sanity.mutual_coverage_subset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutual_coverage_subset</span></code></a>, <a class="reference internal" href="#lingpy.compare.sanity.average_coverage" title="lingpy.compare.sanity.average_coverage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_coverage</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Compute coverage for the KSL.qlc dataset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.compare.sanity</span> <span class="kn">import</span> <span class="n">mutual_coverage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.tests.util</span> <span class="kn">import</span> <span class="n">test_data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span> <span class="o">=</span> <span class="n">Wordlist</span><span class="p">(</span><span class="n">test_data</span><span class="p">(</span><span class="s1">&#39;KSL.qlc&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span> <span class="o">=</span> <span class="n">mutual_coverage</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span><span class="p">[</span><span class="s1">&#39;English&#39;</span><span class="p">][</span><span class="s1">&#39;German&#39;</span><span class="p">]</span>
<span class="go">200</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.sanity.mutual_coverage_check">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.sanity.</span></span><span class="sig-name descname"><span class="pre">mutual_coverage_check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wordlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concepts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'concept'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.sanity.mutual_coverage_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a given mutual coverage is fulfilled by the dataset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wordlist</strong> : ~lingpy.basic.wordlist.Wordlist</p>
<blockquote>
<div><p>Your Wordlist object (or a descendant class).</p>
</div></blockquote>
<p><strong>concepts</strong> : str (default=”concept”)</p>
<blockquote>
<div><p>The column which stores your concepts.</p>
</div></blockquote>
<p><strong>threshold</strong> : int</p>
<blockquote>
<div><p>The threshold which should be checked.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>c: bool</strong> :</p>
<blockquote>
<div><p>True, if coverage is fulfilled for all language pairs, False if
otherwise.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#lingpy.compare.sanity.mutual_coverage" title="lingpy.compare.sanity.mutual_coverage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutual_coverage</span></code></a>, <a class="reference internal" href="#lingpy.compare.sanity.mutual_coverage_subset" title="lingpy.compare.sanity.mutual_coverage_subset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutual_coverage_subset</span></code></a>, <a class="reference internal" href="#lingpy.compare.sanity.average_coverage" title="lingpy.compare.sanity.average_coverage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_coverage</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Compute minimal mutual coverage for the KSL dataset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.compare.sanity</span> <span class="kn">import</span> <span class="n">mutual_coverage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.tests.util</span> <span class="kn">import</span> <span class="n">test_data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span> <span class="o">=</span> <span class="n">Wordlist</span><span class="p">(</span><span class="n">test_data</span><span class="p">(</span><span class="s1">&#39;KSL.qlc&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wl</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="go">        if mutual_coverage_check(wl, i):</span>
<span class="go">            print(&#39;mutual coverage is {0}&#39;.format(i))</span>
<span class="go">            break</span>
<span class="go">    200</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.sanity.mutual_coverage_subset">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.sanity.</span></span><span class="sig-name descname"><span class="pre">mutual_coverage_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wordlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concepts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'concept'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.sanity.mutual_coverage_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute maximal mutual coverage for all language in a wordlist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wordlist</strong> : ~lingpy.basic.wordlist.Wordlist</p>
<blockquote>
<div><p>Your Wordlist object (or a descendant class).</p>
</div></blockquote>
<p><strong>concepts</strong> : str (default=”concept”)</p>
<blockquote>
<div><p>The column which stores your concepts.</p>
</div></blockquote>
<p><strong>threshold</strong> : int</p>
<blockquote>
<div><p>The threshold which should be checked.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>coverage</strong> : tuple</p>
<blockquote>
<div><p>A tuple consisting of the number of languages for which the coverage
could be found as well as a list of all pairings in which this coverage
is possible. The list itself contains the mutual coverage inside each
pair and the list of languages.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#lingpy.compare.sanity.mutual_coverage" title="lingpy.compare.sanity.mutual_coverage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutual_coverage</span></code></a>, <a class="reference internal" href="#lingpy.compare.sanity.mutual_coverage_check" title="lingpy.compare.sanity.mutual_coverage_check"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutual_coverage_check</span></code></a>, <a class="reference internal" href="#lingpy.compare.sanity.average_coverage" title="lingpy.compare.sanity.average_coverage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_coverage</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>Compute all sets of languages with coverage at 200 for the KSL dataset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.compare.sanity</span> <span class="kn">import</span> <span class="n">mutual_coverage_subset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.tests.util</span> <span class="kn">import</span> <span class="n">test_data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span> <span class="o">=</span> <span class="n">Wordlist</span><span class="p">(</span><span class="n">test_data</span><span class="p">(</span><span class="s1">&#39;KSL.qlc&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">number_of_languages</span><span class="p">,</span> <span class="n">pairs</span> <span class="o">=</span> <span class="n">mutual_coverage_subset</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">number_of_items</span><span class="p">,</span> <span class="n">languages</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
<span class="go">        print(number_of_items, &#39;,&#39;.join(languages))</span>
<span class="go">    200 Albanian,English,French,German,Hawaiian,Navajo,Turkish</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.sanity.synonymy">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.sanity.</span></span><span class="sig-name descname"><span class="pre">synonymy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wordlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concepts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'concept'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">languages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'doculect'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.sanity.synonymy" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the number of synonyms per language and concept.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wordlist</strong> : ~lingpy.basic.wordlist.Wordlist</p>
<blockquote>
<div><p>Your Wordlist object (or a descendant class).</p>
</div></blockquote>
<p><strong>concepts</strong> : str (default=”concept”)</p>
<blockquote>
<div><p>The column which stores your concepts.</p>
</div></blockquote>
<p><strong>languages</strong> : str (default=”doculect”)</p>
<blockquote>
<div><p>The column which stores your language names.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>synonyms</strong> : dict</p>
<blockquote>
<div><p>A dictionary with language and concept as key and the number of
synonyms as value.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Calculate synonymy in KSL.qlc dataset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.compare.sanity</span> <span class="kn">import</span> <span class="n">synonymy</span>      
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.tests.util</span> <span class="kn">import</span> <span class="n">test_data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span> <span class="o">=</span> <span class="n">Wordlist</span><span class="p">(</span><span class="n">test_data</span><span class="p">(</span><span class="s1">&#39;KSL.qlc&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">syns</span> <span class="o">=</span> <span class="n">synonymy</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">syns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="go">        if b &gt; 1:</span>
<span class="go">            print(a[0], a[1], b)</span>
</pre></div>
</div>
<p>There is no case where synonymy exceeds 1 word per concept per language,
since <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Kessler2001"><span class="pre">Kessler2001</span></a></code> was paying particular attention to avoid
synonyms.</p>
</dd></dl>

</section>
<section id="module-lingpy.compare.strings">
<span id="lingpy-compare-strings-module"></span><h2>lingpy.compare.strings module<a class="headerlink" href="#module-lingpy.compare.strings" title="Permalink to this headline">¶</a></h2>
<p>Module provides various string similarity metrics.</p>
<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.bidist1">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">bidist1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.bidist1" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes bigram-based distance.</p>
<p class="rubric">Notes</p>
<p>The binary version.
Checks if two bigrams are equal or not.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.bidist2">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">bidist2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.bidist2" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes bigram based distance.</p>
<p class="rubric">Notes</p>
<p>The comprehensive version of the
bigram distance.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.bidist3">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">bidist3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.bidist3" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes bigram based distance.</p>
<p class="rubric">Notes</p>
<p>Computes the positional version of the
bigrams. Assigns a partial distance between two bigrams based on positional
similarity of bigrams.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.bisim1">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">bisim1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.bisim1" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the binary version of bigram similarity.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.bisim2">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">bisim2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.bisim2" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes bigram similarity “the comprehensive version”.</p>
<p class="rubric">Notes</p>
<p>Computes the
number of common 1-grams between two n-grams.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.bisim3">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">bisim3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.bisim3" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes bi-sim the positional version.</p>
<p class="rubric">Notes</p>
<p>The partial similarity between two
bigrams is defined as the number of matching 1-grams at each position.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.dice">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">dice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.dice" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Dice measure that measures the number of common bigrams.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.ident">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">ident</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.ident" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the identity between two strings. If yes, returns 1, else, returns 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.jcd">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">jcd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.jcd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the bigram-based Jaccard Index.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.jcdn">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">jcdn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.jcdn" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the bigram and trigram-based Jaccard Index</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.lcs">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">lcs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.lcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the longest common subsequence between two strings.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.ldn">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">ldn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.ldn" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic Levenshtein distance without swap operation (all operations are equal costs).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="lingpy.align.html#lingpy.align.pairwise.edit_dist" title="lingpy.align.pairwise.edit_dist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lingpy.align.pairwise.edit_dist</span></code></a>, <a class="reference internal" href="#lingpy.compare.strings.ldn_swap" title="lingpy.compare.strings.ldn_swap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lingpy.compare.strings.ldn_swap</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.ldn_swap">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">ldn_swap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.ldn_swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic Levenshtein distance with swap operation included (identifies metathesis).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.prefix">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">prefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the longest common prefix between two strings.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.tridist1">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">tridist1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.tridist1" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes trigram-based distance.</p>
<p class="rubric">Notes</p>
<p>The binary version.
Checks if two trigrams are equal or not.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.tridist2">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">tridist2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.tridist2" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes bigram based distance.</p>
<p class="rubric">Notes</p>
<p>The comprehensive version of the
bigram distance.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.tridist3">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">tridist3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.tridist3" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes trigram based distance.</p>
<p class="rubric">Notes</p>
<p>Computes the positional version of the
trigrams. Assigns a partial distance between two trigrams based on positional
similarity of trigrams.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.trigram">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">trigram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.trigram" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the number of common trigrams between two strings.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.trisim1">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">trisim1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.trisim1" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the binary version of trigram similarity.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.trisim2">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">trisim2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.trisim2" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes tri-sim “the comprehensive version”.</p>
<p class="rubric">Notes</p>
<p>Simply computes the number of common 1-grams between two n-grams instead of
calling LCS as should be done in <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Kondrak2005"><span class="pre">Kondrak2005</span></a></code> paper. Note that the
LCS for a trigram can be computed in O(n) time if we asssume that list
lookup is in constant time.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.trisim3">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">trisim3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.trisim3" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes tri-sim the “positional version”.</p>
<p class="rubric">Notes</p>
<p>Simply computes the
number of matching 1-grams in each position.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.xdice">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">xdice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.xdice" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the skip 1 character version of Dice.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.compare.strings.xxdice">
<span class="sig-prename descclassname"><span class="pre">lingpy.compare.strings.</span></span><span class="sig-name descname"><span class="pre">xxdice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.compare.strings.xxdice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the XXDice between two strings.</p>
<p class="rubric">Notes</p>
<p>Taken from <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brew1996"><span class="pre">Brew1996</span></a></code>.</p>
</dd></dl>

</section>
<section id="module-lingpy.compare.util">
<span id="lingpy-compare-util-module"></span><h2>lingpy.compare.util module<a class="headerlink" href="#module-lingpy.compare.util" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-lingpy.compare">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lingpy.compare" title="Permalink to this headline">¶</a></h2>
<p>Basic module for language comparison.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/lingpy.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">lingpy.compare package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-lingpy.compare.lexstat">lingpy.compare.lexstat module</a></li>
<li><a class="reference internal" href="#module-lingpy.compare.partial">lingpy.compare.partial module</a></li>
<li><a class="reference internal" href="#module-lingpy.compare.phylogeny">lingpy.compare.phylogeny module</a></li>
<li><a class="reference internal" href="#module-lingpy.compare.sanity">lingpy.compare.sanity module</a></li>
<li><a class="reference internal" href="#module-lingpy.compare.strings">lingpy.compare.strings module</a></li>
<li><a class="reference internal" href="#module-lingpy.compare.util">lingpy.compare.util module</a></li>
<li><a class="reference internal" href="#module-lingpy.compare">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/lingpy.compare.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
  <li><a href="../download.html">Download</a></li>

        <li class="nav-item nav-item-this"><a href="">lingpy.compare package</a></li> 
      </ul>
    </div>
 <div id="footer" style="align-items:center;padding-top:5px;padding-left:0px;display:flex;justify-content:space-between;">

   <div>
     <a href="http://shh.mpg.de"><img width="60px" src="../_static/minerva.png" alt="MPG-SSH" /></a>
   </div>
  <div>
    <a href="http://dfg.de/"><img width="80px" src="../_static/dfg_logo_schwarz.jpg" alt="DFG" /></a>
  </div>

  <div style="max-width:300px;">
    <p style="font-size:70%">Created using <a href="http://sphinx-doc.org">Sphinx</a>. Last updated
    on Nov 26, 2021<br>
      This work is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by/4.0/">Creative
      Commons Attributio 4.0 International License</a>.</p>
    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0;width:100px;"
		    src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a> </p>
  </div>

  <div>
    <a href="http://erc.europa.eu/"><img width="80px" src="../_static/European_Research_Council_logo.svg" alt="ERC" /></a>
  </div>
  <div style="max-width:150px;text-align:right;">
    <a href="http://github.com/lingpy/lingpy/">Application source on</a> 
    <a href="https://github.com/"><img width="100px" src="../_static/GitHub_Logo.png" alt="github logo" /></a>
</div>
</div>

  </body>
</html>