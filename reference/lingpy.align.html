
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>lingpy.align package &#8212; LingPy</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/lingpy.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<link rel="stylesheet" type="text/css" href="_static/handheld.css" media="screen and (max-device-width: 720px)" />
<style>
li.nav-item{display: None!important};
</style>

  </head><body>
<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
LingPy
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
  <li><a href="../download.html">Download</a></li>

        <li class="nav-item nav-item-this"><a href="">lingpy.align package</a></li> 
      </ul>
    </div>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="lingpy-align-package">
<h1>lingpy.align package<a class="headerlink" href="#lingpy-align-package" title="Permalink to this headline">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-lingpy.align.multiple">
<span id="lingpy-align-multiple-module"></span><h2>lingpy.align.multiple module<a class="headerlink" href="#module-lingpy.align.multiple" title="Permalink to this headline">¶</a></h2>
<p>Module provides classes and functions for multiple alignment analyses.</p>
<dl class="py class">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lingpy.align.multiple.</span></span><span class="sig-name descname"><span class="pre">Multiple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Basic class for multiple sequence alignment analyses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seqs</strong> : list</p>
<blockquote>
<div><p>List of sequences that shall be aligned.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Depending on the structure of the sequences, further keywords can be
specified that manage how the items get tokenized.</p>
<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.align">
<span class="sig-name descname"><span class="pre">align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.align" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.get_local_peaks">
<span class="sig-name descname"><span class="pre">get_local_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_local_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all peaks in a given alignment.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>threshold</strong> : { int, float } (default=2)</p>
<blockquote>
<div><p>The threshold to determine whether a given column is a peak or not.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0.0)</p>
<blockquote>
<div><p>The weight for gaps.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.get_pairwise_alignments">
<span class="sig-name descname"><span class="pre">get_pairwise_alignments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_pairwise_alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Function creates a dictionary of all pairwise alignments  scores.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_calc</strong> : bool (default=True)</p>
<blockquote>
<div><p>Specify, whether the analysis should be repeated from the
beginning, or whether already conducted analyses should be carried
out.</p>
</div></blockquote>
<p><strong>model</strong> : string (default=”sca”)</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li><p>“dolgo” – a sound-class model based on <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></code>,</p></li>
<li><p>“sca” – an extension of the “dolgo” sound-class model based on
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>, and</p></li>
<li><p>“asjp” – an independent sound-class model which is based on the
sound-class model of <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></code> and the empirical data
of <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></code> (see the description in
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></code>.</p></li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : string (default=”global”)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li><p>“global” – traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</p></li>
<li><p>“dialign” – global alignment analysis which seeks to maximize
local similarities <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</p></li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-3)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=”T”)</p>
<blockquote>
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>) and
should therefore be aligned specifically. This defaults to “T”,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.get_peaks">
<span class="sig-name descname"><span class="pre">get_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gap_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the profile score for each column of the alignment.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>peaks</strong> : list</p>
<blockquote>
<div><p>A list containing the profile scores for each column of the given
alignment.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.get_pid">
<span class="sig-name descname"><span class="pre">get_pid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Percentage Identity (PID) score of the calculated MSA.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mode</strong> : { 1, 2, 3, 4, 5 } (default=1)</p>
<blockquote>
<div><p>Indicate which of the four possible PID scores described in
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Raghava2006"><span class="pre">Raghava2006</span></a></code> should be calculated, the fifth possibility is added
for linguistic purposes:</p>
<ol class="arabic simple">
<li><p>identical positions / (aligned positions + internal gap positions),</p></li>
<li><p>identical positions / aligned positions,</p></li>
<li><p>identical positions / shortest sequence, or</p></li>
<li><p>identical positions / shortest sequence (including internal gap
pos.)</p></li>
<li><p>identical positions / (aligned positions + 2 * number of gaps)</p></li>
</ol>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>score</strong> : float</p>
<blockquote>
<div><p>The PID score of the given alignment as a floating point number between
0 and 1.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="lingpy.sequence.html#lingpy.sequence.sound_classes.pid" title="lingpy.sequence.sound_classes.pid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lingpy.sequence.sound_classes.pid</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.iterate_all_sequences">
<span class="sig-name descname"><span class="pre">iterate_all_sequences</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'final'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'global'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restricted_chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'T_'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterative refinement based on a complete realignment of all sequences.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>check</strong> : { “final”, “immediate” } (default=”final”)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (“immediate”) or after all iterations have been carried
out (“final”).</p>
</div></blockquote>
<p><strong>mode</strong> : { “global”, “overlap”, “dialign” } (default=”global”)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li><p>“global” – traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</p></li>
<li><p>“dialign” – global alignment analysis which seeks to maximize
local similarities <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</p></li>
<li><p>“overlap” – semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</p></li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1981"><span class="pre">Gotoh1981</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="lingpy.align.multiple.Multiple.iterate_clusters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_clusters</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="lingpy.align.multiple.Multiple.iterate_similar_gap_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_similar_gap_sites</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_orphans" title="lingpy.align.multiple.Multiple.iterate_orphans"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_orphans</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method essentially follows the iterative method of
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Barton1987"><span class="pre">Barton1987</span></a></code> with the exception that an MSA has already been
calculated.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.iterate_clusters">
<span class="sig-name descname"><span class="pre">iterate_clusters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'final'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'global'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restricted_chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'T_'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterative refinement based on a flat cluster analysis of the data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>threshold</strong> : float</p>
<blockquote>
<div><p>The threshold for the flat cluster analysis.</p>
</div></blockquote>
<p><strong>check</strong> : string (default=”final”)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (“immediate”) or after all iterations have been carried
out (“final”).</p>
</div></blockquote>
<p><strong>mode</strong> : { “global”, “overlap”, “dialign” } (default=”global”)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li><p>‘global’ – traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</p></li>
<li><p>‘dialign’ – global alignment analysis which seeks to maximize
local similarities <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</p></li>
<li><p>‘overlap’ – semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</p></li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1981"><span class="pre">Gotoh1981</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="lingpy.align.multiple.Multiple.iterate_similar_gap_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_similar_gap_sites</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="lingpy.align.multiple.Multiple.iterate_all_sequences"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_all_sequences</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method uses the <a class="reference internal" href="lingpy.algorithm.html#lingpy.algorithm.clustering.flat_upgma" title="lingpy.algorithm.clustering.flat_upgma"><code class="xref py py-func docutils literal notranslate"><span class="pre">lingpy.algorithm.clustering.flat_upgma()</span></code></a>
function in order to retrieve a flat cluster of the data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.iterate_orphans">
<span class="sig-name descname"><span class="pre">iterate_orphans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'final'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'global'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restricted_chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'T_'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_orphans" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the most divergent sequences in the sample.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>check</strong> : string (default=”final”)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (“immediate”) or after all iterations have been carried
out (“final”).</p>
</div></blockquote>
<p><strong>mode</strong> : { “global”, “overlap”, “dialign” } (default=”global”)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li><p>“global” – traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</p></li>
<li><p>“dialign” – global alignment analysis which seeks to maximize
local similarities <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</p></li>
<li><p>“overlap” – semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</p></li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1981"><span class="pre">Gotoh1981</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="lingpy.align.multiple.Multiple.iterate_clusters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_clusters</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="lingpy.align.multiple.Multiple.iterate_similar_gap_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_similar_gap_sites</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="lingpy.align.multiple.Multiple.iterate_all_sequences"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_all_sequences</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The most divergent sequences are those whose average distance to all
other sequences is above the average distance of all sequence pairs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.iterate_similar_gap_sites">
<span class="sig-name descname"><span class="pre">iterate_similar_gap_sites</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'final'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'global'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restricted_chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'T_'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterative refinement based on the <em>Similar Gap Sites</em> heuristic.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>check</strong> : { “final”, “immediate” } (default=”final”)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (“immediate”) or after all iterations have been carried
out (“final”).</p>
</div></blockquote>
<p><strong>mode</strong> : { “global”, “overlap”, “dialign” } (default=”global”)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li><p>‘global’ – traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</p></li>
<li><p>‘dialign’ – global alignment analysis which seeks to maximize
local similarities <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</p></li>
<li><p>‘overlap’ – semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</p></li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When, e.g., set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="lingpy.align.multiple.Multiple.iterate_clusters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_clusters</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="lingpy.align.multiple.Multiple.iterate_all_sequences"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_all_sequences</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_orphans" title="lingpy.align.multiple.Multiple.iterate_orphans"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Multiple.iterate_orphans</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This heuristic is fairly simple. The idea is to try to split a given
MSA into partitions with identical gap sites.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.lib_align">
<span class="sig-name descname"><span class="pre">lib_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.lib_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a library-based progressive alignment analysis of the sequences.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> : { “dolgo”, “sca”, “asjp” } (default=”sca”)</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li><p>“dolgo” – a sound-class model based on <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></code>,</p></li>
<li><p>“sca” – an extension of the “dolgo” sound-class model based on
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>, and</p></li>
<li><p>“asjp” – an independent sound-class model which is based on the
sound-class model of <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></code> and the empirical data
of <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></code> (see the description in
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></code>.</p></li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : { “global”, “dialign” } (default=”global”)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li><p>“global” – traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</p></li>
<li><p>“dialign” – global alignment analysis which seeks to maximize
local similarities <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</p></li>
</ul>
</div></blockquote>
<p><strong>modes</strong> : list (default=[(“global”,-10,0.6),(“local”,-1,0.6)])</p>
<blockquote>
<div><p>Indicate the mode, the gap opening penalties (GOP), and the gap extension
scale (GEP scale), of the pairwise alignment analyses which
are used to create the library.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { “neighbor”, “upgma” } (default=”upgma”)</p>
<blockquote>
<div><p>The cluster algorithm which shall be used for the calculation of
the guide tree. Select between <code class="docutils literal notranslate"><span class="pre">neighbor</span></code>, the Neighbor-Joining
algorithm (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Saitou1987"><span class="pre">Saitou1987</span></a></code>), and <code class="docutils literal notranslate"><span class="pre">upgma</span></code>, the UPGMA
algorithm (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></code>).</p>
</div></blockquote>
<p><strong>guide_tree</strong> : tree_matrix</p>
<blockquote>
<div><p>Use a custom guide tree instead of performing a cluster algorithm
for constructing one based on the input similarities. The use of this
option makes the tree_calc option irrelevant.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=”T”)</p>
<blockquote>
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>) and
should therefore be aligned specifically. This defaults to “T”,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In contrast to traditional progressive multiple sequence alignment
approaches such as <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Feng1981"><span class="pre">Feng1981</span></a></code> and <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Thompson1994"><span class="pre">Thompson1994</span></a></code>,
library-based progressive alignment <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Notredame2000"><span class="pre">Notredame2000</span></a></code> is based on
a pre-processing of the data where the information given in global and
local pairwise alignments of the input sequences is used to derive a
refined scoring function (<em>library</em>) which is later used in the
progressive phase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.prog_align">
<span class="sig-name descname"><span class="pre">prog_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.prog_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a progressive alignment analysis of the input sequences.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> : { “dolgo”, “sca”, “asjp” } (defaul=”sca”)</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li><p>“dolgo” – a sound-class model based on <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></code>,</p></li>
<li><p>“sca” – an extension of the “dolgo” sound-class model based on
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>, and</p></li>
<li><p>“asjp” – an independent sound-class model which is based on the
sound-class model of <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></code> and the empirical data
of <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></code> (see the description in
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></code>.</p></li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : { “global”, “dialign” } (default=”global”)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li><p>“global” – traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</p></li>
<li><p>“dialign” – global alignment analysis which seeks to maximize
local similarities <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</p></li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-2)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { “neighbor”, “upgma” } (default=”upgma”)</p>
<blockquote>
<div><p>The cluster algorithm which shall be used for the calculation of
the guide tree. Select between <code class="docutils literal notranslate"><span class="pre">neighbor</span></code>, the Neighbor-Joining
algorithm (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Saitou1987"><span class="pre">Saitou1987</span></a></code>), and <code class="docutils literal notranslate"><span class="pre">upgma</span></code>, the UPGMA
algorithm (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></code>).</p>
</div></blockquote>
<p><strong>guide_tree</strong> : tree_matrix</p>
<blockquote>
<div><p>Use a custom guide tree instead of performing a cluster algorithm
for constructing one based on the input similarities. The use of this
option makes the tree_calc option irrelevant.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=”T”)</p>
<blockquote>
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>) and
should therefore be aligned specifically. This defaults to “T”,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.sum_of_pairs">
<span class="sig-name descname"><span class="pre">sum_of_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alm_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'self'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.sum_of_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the sum-of-pairs score for a given alignment analysis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>alm_matrix</strong> : { “self”, “other” } (default=”self”)</p>
<blockquote>
<div><p>Indicate for which MSA the sum-of-pairs score shall be calculated.</p>
</div></blockquote>
<p><strong>mat</strong> : { None, list }</p>
<blockquote>
<div><p>If “other” is chosen as an option for <strong>alm_matrix</strong>, define for
which matrix the sum-of-pairs score shall be calculated.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>The sum-of-pairs score of the alignment.</strong> :</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.multiple.Multiple.swap_check">
<span class="sig-name descname"><span class="pre">swap_check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">swap_penalty</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'classes'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.swap_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for possibly swapped sites in the alignment.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>swap_penalty</strong> : { int, float } (default=-3)</p>
<blockquote>
<div><p>Specify the penalty for swaps in the alignment.</p>
</div></blockquote>
<p><strong>score_mode</strong> : { “classes”, “library” } (default=”classes”)</p>
<blockquote>
<div><p>Define the score-mode of the calculation which is either based on
sound classes proper, or on the specific scores derived from the
library approach.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> : bool</p>
<blockquote>
<div><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, if a swap was identified, and <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise. The information regarding the position of the swap is
stored in the attribute <code class="docutils literal notranslate"><span class="pre">swap_index</span></code>.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method for swap detection is described in detail in <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>.</p>
<p class="rubric">Examples</p>
<p>Define a set of strings whose alignment contans a swap.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span> <span class="o">=</span> <span class="n">Multiple</span><span class="p">([</span><span class="s2">&quot;woldemort&quot;</span><span class="p">,</span> <span class="s2">&quot;waldemar&quot;</span><span class="p">,</span> <span class="s2">&quot;wladimir&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Align the data, using the progressive approach.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span><span class="o">.</span><span class="n">prog_align</span><span class="p">()</span>
</pre></div>
</div>
<p>Check for swaps.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span><span class="o">.</span><span class="n">swap_check</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Print the alignment</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
<span class="go">w   o   l   -   d   e   m   o   r   t</span>
<span class="go">w   a   l   -   d   e   m   a   r   -</span>
<span class="go">v   -   l   a   d   i   m   i   r   -</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.align.multiple.mult_align">
<span class="sig-prename descclassname"><span class="pre">lingpy.align.multiple.</span></span><span class="sig-name descname"><span class="pre">mult_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'upgma'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scoredict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.mult_align" title="Permalink to this definition">¶</a></dt>
<dd><p>A short-cut method for multiple alignment analyses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seqs</strong> : list</p>
<blockquote>
<div><p>The input sequences.</p>
</div></blockquote>
<p><strong>gop = int (default=-1)</strong> :</p>
<blockquote>
<div><p>The gap opening penalty.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The scaling factor by which penalties for gap extensions are decreased.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { “upgma” “neighbor” } (default=”upgma”)</p>
<blockquote>
<div><p>The algorithm which is used for the calculation of the guide tree.</p>
</div></blockquote>
<p><strong>pprint</strong> : bool (default=False)</p>
<blockquote>
<div><p>Indicate whether results shall be printed onto screen.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>alignments</strong> : list</p>
<blockquote>
<div><p>A two-dimensional list in which alignments are represented as a list of
tokens.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">mult_align</span><span class="p">([</span><span class="s2">&quot;woldemort&quot;</span><span class="p">,</span> <span class="s2">&quot;waldemar&quot;</span><span class="p">,</span> <span class="s2">&quot;vladimir&quot;</span><span class="p">],</span> <span class="n">pprint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">w   o   l   -   d   e   m   o   r   t</span>
<span class="go">w   a   l   -   d   e   m   a   r   -</span>
<span class="go">-   v   l   a   d   i   m   i   r   -</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-lingpy.align.pairwise">
<span id="lingpy-align-pairwise-module"></span><h2>lingpy.align.pairwise module<a class="headerlink" href="#module-lingpy.align.pairwise" title="Permalink to this headline">¶</a></h2>
<p>Module provides classes and functions for pairwise alignment analyses.</p>
<dl class="py class">
<dt class="sig sig-object py" id="lingpy.align.pairwise.Pairwise">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lingpy.align.pairwise.</span></span><span class="sig-name descname"><span class="pre">Pairwise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seqB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.Pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Basic class for the handling of pairwise sequence alignments (PSA).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seqs</strong> : string list</p>
<blockquote>
<div><p>Either the first string of a sequence pair that shall be aligned,
or a list of sequence tuples.</p>
</div></blockquote>
<p><strong>seqB</strong> : string or bool (default=None)</p>
<blockquote>
<div><p>Define the second sequence that shall be aligned with the first
sequence, if only two sequences shall be compared.</p>
</div></blockquote>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.pairwise.Pairwise.align">
<span class="sig-name descname"><span class="pre">align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.Pairwise.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a pair of sequences or multiple sequence pairs.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gop</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap opening penalty (GOP).</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The gap extension penalty (GEP), calculated with help of a scaling
factor.</p>
</div></blockquote>
<p><strong>mode</strong> : {“global”,”local”,”overlap”,”dialign”}</p>
<blockquote>
<div><p>The alignment mode, see <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></code> for details.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default = 0.3)</p>
<blockquote>
<div><p>The factor by which matches in identical prosodic position are
increased.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : str (default=”<a href="#id1"><span class="problematic" id="id2">T_</span></a>”)</p>
<blockquote>
<div><p>The restricted chars that function as an indicator of syllable or
morpheme breaks for secondary alignment, see <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012c"><span class="pre">List2012c</span></a></code>
for details.</p>
</div></blockquote>
<p><strong>distance</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to <em>True</em>, return the distance instead of the similarity
score. Distance is calculated using the formula by
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Downey2008"><span class="pre">Downey2008</span></a></code>.</p>
</div></blockquote>
<p><strong>model</strong> : { None, ~lingpy.data.model.Model }</p>
<blockquote>
<div><p>Specify the sound class model that shall be used for the analysis.
If no model is specified, the default model of <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></code>
will be used.</p>
</div></blockquote>
<p><strong>pprint</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to <em>True</em>, the alignments are printed to the screen.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.align.pairwise.edit_dist">
<span class="sig-prename descclassname"><span class="pre">lingpy.align.pairwise.</span></span><span class="sig-name descname"><span class="pre">edit_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seqB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restriction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.edit_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edit distance between two strings.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seqA,seqB</strong> : str</p>
<blockquote>
<div><p>The strings that shall be compared.</p>
</div></blockquote>
<p><strong>normalized</strong> : bool (default=False)</p>
<blockquote>
<div><p>Specify whether the normalized edit distance shall be returned. If no
restrictions are chosen, the edit distance is normalized by dividing by
the length of the longer string. If <em>restriction</em> is set to <em>cv</em>
(consonant-vowel), the edit distance is normalized by the length of the
alignment.</p>
</div></blockquote>
<p><strong>restriction</strong> : {“cv”} (default=””)</p>
<blockquote>
<div><p>Specify the restrictions to be used. Currently, only <code class="docutils literal notranslate"><span class="pre">cv</span></code> is
supported. This prohibits matches of vowels with consonants.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dist</strong> : {int float}</p>
<blockquote>
<div><p>The edit distance, which is a float if normalized is set to c{True},
and an integer otherwise.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The edit distance was first formally defined by V. I. Levenshtein
(<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Levenshtein1965"><span class="pre">Levenshtein1965</span></a></code>). The first algorithm to compute the edit
distance was proposed by Wagner and Fisher (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Wagner1974"><span class="pre">Wagner1974</span></a></code>).</p>
<p class="rubric">Examples</p>
<dl>
<dt>Align two sequences::</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s1">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seqB</span> <span class="o">=</span> <span class="s1">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edit_dist</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.align.pairwise.nw_align">
<span class="sig-prename descclassname"><span class="pre">lingpy.align.pairwise.</span></span><span class="sig-name descname"><span class="pre">nw_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seqB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scorer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.nw_align" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Carry out the traditional Needleman-Wunsch algorithm.</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<dl class="simple">
<dt>scorer<span class="classifier">dict (default=False)</span></dt><dd><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings (segment matches need to
be passed as tuples of two segments, following the order of the input
sequences). Note also that the scorer can well be asymmetric, so you
could also use it for two completely different alphabets. All you need
to make sure is that the tuples representing the segment matches follow
the order of your input sequences.</p>
</dd>
<dt>gap<span class="classifier">int (default=-1)</span></dt><dd><p>The gap penalty.</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>alm</strong> : tuple</p>
<blockquote>
<div><p>A tuple consisting of the aligments of the first and the second
sequence, and the alignment score.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Needleman-Wunsch algorithm (see <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>) returns a global
alignment of two sequences.</p>
<dl>
<dt>‘+’ ‘.join(almB), “(sim={0})”.format(sim))</dt><dd><blockquote>
<div><p>a b a b -
- b a b a (sim=1)</p>
</div></blockquote>
<p>Nothing unexpected so far, you could reach the same result without the
scorer. But now let’s make a scorer that favors mismatches for our little
two-letter alphabet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scorer</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span> <span class="o">=</span> <span class="s1">&#39;abab&#39;</span><span class="p">,</span> <span class="s1">&#39;baba&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">almA</span><span class="p">,</span> <span class="n">almB</span><span class="p">,</span> <span class="n">sim</span> <span class="o">=</span> <span class="n">nw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">,</span> <span class="n">scorer</span><span class="o">=</span><span class="n">scorer</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">almA</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span>
</pre></div>
</div>
</dd>
<dt>‘+’ ‘.join(almB), “(sim={0})”.format(sim))</dt><dd><blockquote>
<div><p>a b a b
b a b a (sim=4)</p>
</div></blockquote>
<p>Now, let’s analyse two strings which are completely different, but where we
use the scorer to define mappings between the segments. We simply do this
by using lower case letters in one and upper case letters in the other
case, which will, of course, be treated as different symbols in Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scorer</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span> <span class="o">=</span> <span class="s1">&#39;ABAB&#39;</span><span class="p">,</span> <span class="s1">&#39;aa&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">almA</span><span class="p">,</span> <span class="n">almB</span><span class="p">,</span> <span class="n">sim</span> <span class="o">=</span> <span class="n">nw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">,</span> <span class="n">scorer</span><span class="o">=</span><span class="n">scorer</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">almA</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span>
</pre></div>
</div>
</dd>
<dt>‘+’ ‘.join(almB), “(sim={0})”.format(sim))</dt><dd><p>A B A B
a - a - (sim=0)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.align.pairwise.pw_align">
<span class="sig-prename descclassname"><span class="pre">lingpy.align.pairwise.</span></span><span class="sig-name descname"><span class="pre">pw_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seqB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scorer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'global'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.pw_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align two sequences in various ways.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>scorer</strong> : dict (default=False)</p>
<blockquote>
<div><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap opening penalty.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The gap extension scale. This scale is similar to the gap extension
penalty, but in contrast to the traditional GEP, it “scales” the gap
opening penalty.</p>
</div></blockquote>
<p><strong>mode</strong> : {“global”, “local”, “dialign”, “overlap”} (default=”global”)</p>
<blockquote>
<div><p>Select between one of the four different alignment modes regularly
implemented in LingPy, see <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></code> for details.</p>
</div></blockquote>
<p><strong>distance</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to c{True} return the distance score following the formula by
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Downey2008"><span class="pre">Downey2008</span></a></code>. Otherwise, return the basic similarity score.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<dl>
<dt>Align two words using the dialign algorithm::</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s1">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seqB</span> <span class="o">=</span> <span class="s1">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;dialign&#39;</span><span class="p">)</span>
<span class="go">([&#39;f&#39;, &#39;a&#39;, &#39;t&#39;, &#39; &#39;, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;],</span>
<span class="go"> [&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;, &#39;f&#39;, &#39;a&#39;, &#39;t&#39;],</span>
<span class="go"> 3.0)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.align.pairwise.structalign">
<span class="sig-prename descclassname"><span class="pre">lingpy.align.pairwise.</span></span><span class="sig-name descname"><span class="pre">structalign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seqB</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.structalign" title="Permalink to this definition">¶</a></dt>
<dd><p>Experimental function for testing structural alignment algorithms.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.align.pairwise.sw_align">
<span class="sig-prename descclassname"><span class="pre">lingpy.align.pairwise.</span></span><span class="sig-name descname"><span class="pre">sw_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seqB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scorer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.sw_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out the traditional Smith-Waterman algorithm.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>scorer</strong> : dict (default=False)</p>
<blockquote>
<div><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings.</p>
</div></blockquote>
<p><strong>gap</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap penalty.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>alm</strong> : tuple</p>
<blockquote>
<div><p>A tuple consisting of prefix, alignment, and suffix of the first and
the second sequence, and the alignment score.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Smith-Waterman algorithm (see <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Smith1981"><span class="pre">Smith1981</span></a></code>) returns a local
alignment between two sequences. A local alignment is an alignment of those
subsequences of the input sequences that yields the highest score.</p>
<p class="rubric">Examples</p>
<dl>
<dt>Align two sequences::</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s1">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seqB</span> <span class="o">=</span> <span class="s1">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">)</span>
<span class="go">(([], [&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], [&#39; &#39;, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;]),</span>
<span class="go"> ([&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], []),</span>
<span class="go"> 3.0)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.align.pairwise.turchin">
<span class="sig-prename descclassname"><span class="pre">lingpy.align.pairwise.</span></span><span class="sig-name descname"><span class="pre">turchin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seqB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dolgo'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.turchin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cognate judgment based on the method by <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Turchin2010"><span class="pre">Turchin2010</span></a></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>model</strong> : {“asjp”, “sca”, “dolgo”} (default=”dolgo”)</p>
<blockquote>
<div><p>A sound-class model instance or a string that denotes one of the
standard sound class models used in LingPy.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cognacy</strong> : {0, 1}</p>
<blockquote>
<div><p>The cognacy assertion which is either 0 (words are probably cognate) or
1 (words are not likely to be cognate).</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.align.pairwise.we_align">
<span class="sig-prename descclassname"><span class="pre">lingpy.align.pairwise.</span></span><span class="sig-name descname"><span class="pre">we_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seqB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scorer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.we_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out the traditional Waterman-Eggert algorithm.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>scorer</strong> : dict (default=False)</p>
<blockquote>
<div><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings.</p>
</div></blockquote>
<p><strong>gap</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap penalty.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>alms</strong> : list</p>
<blockquote>
<div><p>A list consisting of tuples. Each tuple gives the alignment of one of
the subsequences of the input sequences. Each tuple contains the
aligned part of the first, the aligned part of the second sequence, and
the score of the alignment.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Waterman-Eggert algorithm (see <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Waterman1987"><span class="pre">Waterman1987</span></a></code>) returns <em>all</em>
local matches between two sequences.</p>
<p class="rubric">Examples</p>
<dl>
<dt>Align two sequences::</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s1">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seqB</span> <span class="o">=</span> <span class="s1">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">we_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">)</span>
<span class="go">[([&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], 3.0),</span>
<span class="go"> ([&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], 3.0)]</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-lingpy.align.sca">
<span id="lingpy-align-sca-module"></span><h2>lingpy.align.sca module<a class="headerlink" href="#module-lingpy.align.sca" title="Permalink to this headline">¶</a></h2>
<p>Basic module for pairwise and multiple sequence comparison.</p>
<p>The module consists of four classes which deal with pairwise and multiple
sequence comparison from the <em>sequence</em> and the <em>alignment</em> perspective. The
sequence perspective deals with unaligned sequences. The <em>alignment</em>
perspective deals with aligned sequences.</p>
<dl class="py class">
<dt class="sig sig-object py" id="lingpy.align.sca.Alignments">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lingpy.align.sca.</span></span><span class="sig-name descname"><span class="pre">Alignments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">infile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'concept'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'doculect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modify_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_interactive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_on_tones</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cogid'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingpy.basic.html#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingpy.basic.wordlist.Wordlist</span></code></a></p>
<p>Class handles Wordlists for the purpose of alignment analyses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>infile</strong> : str</p>
<blockquote>
<div><p>The name of the input file that should conform to the basic format of
the <cite>~lingpy.basic.wordlist.Wordlist</cite> class and define a specific ID
for cognate sets.</p>
</div></blockquote>
<p><strong>row</strong> : str (default = “concept”)</p>
<blockquote>
<div><p>A string indicating the name of the row that shall be taken as the
basis for the tabular representation of the word list.</p>
</div></blockquote>
<p><strong>col</strong> : str (default = “doculect”)</p>
<blockquote>
<div><p>A string indicating the name of the column that shall be taken as the
basis for the tabular representation of the word list.</p>
</div></blockquote>
<p><strong>conf</strong> : string (default=’’)</p>
<blockquote>
<div><p>A string defining the path to the configuration file.</p>
</div></blockquote>
<p><strong>ref</strong> : string (default=’cogid’)</p>
<blockquote>
<div><p>The name of the column that stores the cognate IDs.</p>
</div></blockquote>
<p><strong>modify_ref</strong> : function (default=False)</p>
<blockquote>
<div><p>Use a function to modify the reference. If your cognate identifiers
are numerical, for example, and negative values are assigned as
loans, but you want to suppress this behaviour, just set this
keyword to “abs”, and all cognate IDs will be converted to their
absolute value.</p>
</div></blockquote>
<p><strong>split_on_tones</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to True, this means that in the case of fuzzy alignment mode,
the algorithm will attempt to split words into morphemes by tones if no
explicit morpheme markers can be found.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This class inherits from <a class="reference internal" href="lingpy.basic.html#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wordlist</span></code></a> and
additionally creates instances of the
<a class="reference internal" href="#lingpy.align.multiple.Multiple" title="lingpy.align.multiple.Multiple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Multiple</span></code></a> class for all cognate sets that
are specified by the <em>ref</em> keyword.</p>
<p class="rubric">Attributes</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 4%" />
<col style="width: 5%" />
<col style="width: 91%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>msa</p></td>
<td><p>dict</p></td>
<td><p>A dictionary storing multiple alignments as dictionaries which can be
directly opened and aligned with help of the ~lingpy.align.sca.SCA
function. The alignment objects are referenced by a key which is
identical with the “reference” (ref-keyword) of the alignment, that is
the name of the column which contains the cognate identifiers.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.sca.Alignments.add_alignments">
<span class="sig-name descname"><span class="pre">add_alignments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modify_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fuzzy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_on_tones</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.add_alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Function adds a new set of alignments to the data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ref: str (default=False)</strong> :</p>
<blockquote>
<div><p>Use this to set the name of the column which contains the cognate
sets.</p>
</div></blockquote>
<p><strong>fuzzy: bool (default=False)</strong> :</p>
<blockquote>
<div><p>If set to true, force the algorithm to treat the cognate sets as
fuzzy cognate sets, i.e., as multiple cognate sets which are in
order assigned to a word (proper “partial cognates”).</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.sca.Alignments.align">
<span class="sig-name descname"><span class="pre">align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a multiple alignment analysis of the data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> : { “progressive”, “library” } (default=”progressive”)</p>
<blockquote>
<div><p>Select the method to use for the analysis.</p>
</div></blockquote>
<p><strong>iteration</strong> : bool (default=False)</p>
<blockquote>
<div><p>Set to c{True} in order to use iterative refinement methods.</p>
</div></blockquote>
<p><strong>swap_check</strong> : bool (default=False)</p>
<blockquote>
<div><p>Set to c{True} in order to carry out a swap-check.</p>
</div></blockquote>
<p><strong>model</strong> : { ‘dolgo’, ‘sca’, ‘asjp’ }</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li><p>“dolgo” – a sound-class model based on <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></code>,</p></li>
<li><p>“sca” – an extension of the “dolgo” sound-class model based on
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>, and</p></li>
<li><p>“asjp” – an independent sound-class model which is based on the
sound-class model of <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></code> and the empirical data
of <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></code> (see the description in
<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></code>.</p></li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : { ‘global’, ‘dialign’ }</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li><p>“global” – traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</p></li>
<li><p>“dialign” – global alignment analysis which seeks to maximize
local similarities <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</p></li>
</ul>
</div></blockquote>
<p><strong>modes</strong> : list (default=[(‘global’,-2,0.5),(‘local’,-1,0.5)])</p>
<blockquote>
<div><p>Indicate the mode, the gap opening penalties (GOP), and the gap
extension scale (GEP scale), of the pairwise alignment analyses
which are used to create the library.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { ‘neighbor’, ‘upgma’ } (default=’upgma’)</p>
<blockquote>
<div><p>The cluster algorithm which shall be used for the calculation of
the guide tree. Select between <code class="docutils literal notranslate"><span class="pre">neighbor</span></code>, the Neighbor-Joining
algorithm (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Saitou1987"><span class="pre">Saitou1987</span></a></code>), and <code class="docutils literal notranslate"><span class="pre">upgma</span></code>, the UPGMA
algorithm (<code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></code>).</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=”T”)</p>
<blockquote>
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <code class="docutils literal notranslate"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>) and
should therefore be aligned specifically. This defaults to “T”,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.sca.Alignments.get_confidence">
<span class="sig-name descname"><span class="pre">get_confidence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scorer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lexstatid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.get_confidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Function creates confidence scores for a given set of alignments.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scorer</strong> : <code class="xref py py-class docutils literal notranslate"><span class="pre">ScoreDict</span></code></p>
<blockquote>
<div><p>A <em>ScoreDict</em> object which gives similarity scores for all segments in
the alignment.</p>
</div></blockquote>
<p><strong>ref</strong> : str (default=”lexstatid”)</p>
<blockquote>
<div><p>The reference entry-type, referring to the cognate-set to be used for
the analysis.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : {loat} (default=1.0)</p>
<blockquote>
<div><p>Determine the weight assigned to matches containing gaps.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.sca.Alignments.get_consensus">
<span class="sig-name descname"><span class="pre">get_consensus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">consensus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'consensus'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counterpart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ipa'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.get_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a consensus string of all MSAs in the wordlist.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msa</strong> : {c{list} ~lingpy.align.multiple.Multiple}</p>
<blockquote>
<div><p>Either an MSA object or an MSA matrix.</p>
</div></blockquote>
<p><strong>tree</strong> : {c{str} ~lingpy.thirdparty.cogent.PhyloNode}</p>
<blockquote>
<div><p>A tree object or a Newick string along which the consensus shall be
calculated.</p>
</div></blockquote>
<p><strong>gaps</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return the gap positions in the consensus.</p>
</div></blockquote>
<p><strong>classes</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>Specify whether sound classes shall be used to calculate the consensus.</p>
</div></blockquote>
<p><strong>model</strong> : ~lingpy.data.model.Model</p>
<blockquote>
<div><p>A sound class model according to which the IPA strings shall be
converted to sound-class strings.</p>
</div></blockquote>
<p><strong>return_data</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>Return the data instead of adding it in a column to the wordlist
object.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.sca.Alignments.get_msa">
<span class="sig-name descname"><span class="pre">get_msa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.get_msa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.sca.Alignments.output">
<span class="sig-name descname"><span class="pre">output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileformat</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write wordlist to file.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fileformat</strong> : {“tsv”, “msa”, “tre”, “nwk”, “dst”, “taxa”, “starling”, “paps.nex”,</p>
<blockquote>
<div><p>“paps.csv” “html”}
The format that is written to file. This corresponds to the file
extension, thus ‘tsv’ creates a file in tsv-format, ‘dst’ creates
a file in Phylip-distance format, etc. Specific output is created
for the formats “html” and “msa”:</p>
<ul class="simple">
<li><p>“msa” will create a folder containing all alignments of all
cognate sets in “msa”-format</p></li>
<li><p>“html” will create html-output in which words are sorted
according to meaning, cognate set, and all cognate words are
aligned</p></li>
</ul>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>Specify the name of the output file (defaults to a filename that
indicates the creation date).</p>
</div></blockquote>
<p><strong>subset</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return only a subset of the data. Which subset
is specified in the keywords ‘cols’ and ‘rows’.</p>
</div></blockquote>
<p><strong>cols</strong> : list</p>
<blockquote>
<div><p>If <em>subset</em> is set to c{True}, specify the columns that shall be
written to the csv-file.</p>
</div></blockquote>
<p><strong>rows</strong> : dict</p>
<blockquote>
<div><p>If <em>subset</em> is set to c{True}, use a dictionary consisting of keys
that specify a column and values that give a Python-statement in
raw text, such as, e.g., “== ‘hand’”. The content of the specified
column will then be checked against statement passed in the
dictionary, and if it is evaluated to c{True}, the respective row
will be written to file.</p>
</div></blockquote>
<p><strong>ref</strong> : str</p>
<blockquote>
<div><p>Name of the column that contains the cognate IDs if ‘starling’ is
chosen as an output format.</p>
</div></blockquote>
<p><strong>missing</strong> : { str, int } (default=0)</p>
<blockquote>
<div><p>If ‘paps.nex’ or ‘paps.csv’ is chosen as fileformat, this character
will be inserted as an indicator of missing data.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : {‘neighbor’, ‘upgma’}</p>
<blockquote>
<div><p>If no tree has been calculated and ‘tre’ or ‘nwk’ is chosen as
output format, the method that is used to calculate the tree.</p>
</div></blockquote>
<p><strong>threshold</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The threshold that is used to carry out a flat cluster analysis if
‘groups’ or ‘cluster’ is chosen as output format.</p>
</div></blockquote>
<p><strong>style</strong> : str (default=”id”)</p>
<blockquote>
<div><p>If “msa” is chosen as output format, this will write the alignments
for each msa-file in a specific format in which the first column
contains a direct reference to the word via its ID in the wordlist.</p>
</div></blockquote>
<p><strong>ignore</strong> : { list, “all” }</p>
<blockquote>
<div><p>Modifies the output format in “tsv” output and allows to ignore
certain blocks in extended “tsv”, like “msa”, “taxa”, “json”, etc.,
which should be passed as a list. If you choose “all” as a plain
string and not a list, this will ignore all additional blocks and
output only plain “tsv”.</p>
</div></blockquote>
<p><strong>prettify</strong> : bool (default=True)</p>
<blockquote>
<div><p>Inserts comment characters between concepts in the “tsv” file
output format, which makes it easier to see blocks of words
denoting the same concept. Switching this off will output the file
in plain “tsv”.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.sca.Alignments.reduce_alignments">
<span class="sig-name descname"><span class="pre">reduce_alignments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.reduce_alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Function reduces alignments which contain columns that are marked to be                 ignored by the user.</p>
<p class="rubric">Notes</p>
<p>This function changes the data only internally: All alignments are
checked as to whether they contain data that should be ignored. If this
is the case, the alignments are then reduced, and stored in a specific
item of the alignment string. If the method doesn’t find any instances
for reduction, it still makes the copies of the alignments in order to
guarantee that the alignments with with we want to work are at the same
place in the dictionary.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingpy.align.sca.MSA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lingpy.align.sca.</span></span><span class="sig-name descname"><span class="pre">MSA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">infile</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.MSA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.align.multiple.Multiple" title="lingpy.align.multiple.Multiple"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingpy.align.multiple.Multiple</span></code></a></p>
<p>Basic class for carrying out multiple sequence alignment analyses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>infile</strong> : file</p>
<blockquote>
<div><p>A file in <code class="docutils literal notranslate"><span class="pre">msq</span></code>-format or <code class="docutils literal notranslate"><span class="pre">msa</span></code>-format.</p>
</div></blockquote>
<p><strong>merge_vowels</strong> : bool (default=True)</p>
<blockquote>
<div><p>Indicate, whether neighboring vowels should be merged into
diphtongs, or whether they should be kept separated during the
analysis.</p>
</div></blockquote>
<p><strong>comment</strong> : char (default=’#’)</p>
<blockquote>
<div><p>The comment character which, inserted in the beginning of a line,
prevents that line from being read.</p>
</div></blockquote>
<p><strong>normalize</strong> : bool (default=True)</p>
<blockquote>
<div><p>Normalize the alignment, that is, add gap characters for all sequences
which are shorter than the longest sequence, and delete all columns
from the alignment in which only gaps occur.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>There are two possible input formats for this class: the MSQ-format, and
the MSA-format (see <a class="reference internal" href="../tutorial/formats.html#msa-formats"><span class="std std-ref">Multiple Alignments (MSQ and MSA)</span></a> for details). This class directly
inherits all methods of the <a class="reference internal" href="#lingpy.align.multiple.Multiple" title="lingpy.align.multiple.Multiple"><code class="xref py py-class docutils literal notranslate"><span class="pre">Multiple</span></code></a>
class.</p>
<p class="rubric">Examples</p>
<p>Get the path to a file from the testset.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">rc</span><span class="p">(</span><span class="s2">&quot;test_path&quot;</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;harry.msq&#39;</span>
</pre></div>
</div>
<p>Load the file into the Multiple class.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span> <span class="o">=</span> <span class="n">Multiple</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>
</div>
<p>Carry out a progressive alignment analysis of the sequences.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span><span class="o">.</span><span class="n">prog_align</span><span class="p">()</span>
</pre></div>
</div>
<p>Print the result to the screen:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
<span class="go">w    o    l    -    d    e    m    o    r    t</span>
<span class="go">w    a    l    -    d    e    m    a    r    -</span>
<span class="go">v    -    l    a    d    i    m    i    r    -</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.sca.MSA.ipa2cls">
<span class="sig-name descname"><span class="pre">ipa2cls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.MSA.ipa2cls" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve sound-class strings from aligned IPA sequences.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> : str (default=’sca’)</p>
<blockquote>
<div><p>The sound-class model according to which the sequences shall be
converted.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is only useful when an <code class="docutils literal notranslate"><span class="pre">msa</span></code>-file with already
conducted alignment analyses was loaded.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.sca.MSA.output">
<span class="sig-name descname"><span class="pre">output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileformat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'msa'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sorted_seqs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique_seqs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.MSA.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to file.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fileformat</strong> : { “psa”, “msa”, “msq” }</p>
<blockquote>
<div><p>Indicate which data should be written to file. Select between:</p>
<ul class="simple">
<li><p>“psa” – output of all pairwise alignments in <code class="docutils literal notranslate"><span class="pre">psa</span></code>-format,</p></li>
<li><p>“msa” – output of the multiple alignment in <code class="docutils literal notranslate"><span class="pre">msa</span></code>-format, or</p></li>
<li><p>“msq” – output of the multiple sequences in <code class="docutils literal notranslate"><span class="pre">msq</span></code>-format.</p></li>
<li><p>“html” – output of the multiple alignment in <code class="docutils literal notranslate"><span class="pre">html</span></code>-format.</p></li>
</ul>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>Select a specific name for the outfile, otherwise, the name of
the infile will be taken by default.</p>
</div></blockquote>
<p><strong>sorted_seqs</strong> : bool</p>
<blockquote>
<div><p>Indicate whether the sequences should be sorted or not (applys only
to ‘msa’ and ‘msq’ output.</p>
</div></blockquote>
<p><strong>unique_seqs</strong> : bool</p>
<blockquote>
<div><p>Indicate whether only unique sequences should be written to file or
not.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lingpy.align.sca.PSA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lingpy.align.sca.</span></span><span class="sig-name descname"><span class="pre">PSA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">infile</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.PSA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.align.pairwise.Pairwise" title="lingpy.align.pairwise.Pairwise"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingpy.align.pairwise.Pairwise</span></code></a></p>
<p>Basic class for dealing with the pairwise alignment of sequences.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>infile</strong> : file</p>
<blockquote>
<div><p>A file in <code class="docutils literal notranslate"><span class="pre">psq</span></code>-format.</p>
</div></blockquote>
<p><strong>merge_vowels</strong> : bool (default=True)</p>
<blockquote>
<div><p>Indicate, whether neighboring vowels should be merged into
diphtongs, or whether they should be kept separated during the
analysis.</p>
</div></blockquote>
<p><strong>comment</strong> : char (default=’#’)</p>
<blockquote>
<div><p>The comment character which, inserted in the beginning of a line,
prevents that line from being read.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In order to read in data from text files, two different file formats can be
used along with this class: the PSQ-format, and the PSA-format (see
<a class="reference internal" href="../tutorial/formats.html#psa-formats"><span class="std std-ref">Pairwise Alignments (PSQ and PSA)</span></a> for details). This class inherits the methods of the
<a class="reference internal" href="#lingpy.align.pairwise.Pairwise" title="lingpy.align.pairwise.Pairwise"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pairwise</span></code></a> class.</p>
<p class="rubric">Attributes</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 5%" />
<col style="width: 87%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>taxa</p></td>
<td><p>list</p></td>
<td><p>A list of tuples containing the taxa of all sequence pairs.</p></td>
</tr>
<tr class="row-even"><td><p>seqs</p></td>
<td><p>list</p></td>
<td><p>A list of tuples containing all sequence pairs.</p></td>
</tr>
<tr class="row-odd"><td><p>tokens</p></td>
<td><p>list</p></td>
<td><p>A list of tuples containing all sequence pairs in a tokenized form.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lingpy.align.sca.PSA.output">
<span class="sig-name descname"><span class="pre">output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileformat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'psa'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.PSA.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the results of the analyses to a text file.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fileformat</strong> : { ‘psa’, ‘psq’ }</p>
<blockquote>
<div><p>Indicate which data should be written to file. Select between:</p>
<ul class="simple">
<li><p>‘psa’ – output of all pairwise alignments in <code class="docutils literal notranslate"><span class="pre">psa</span></code>-format,</p></li>
<li><p>‘psq’ – output of the multiple sequences in <code class="docutils literal notranslate"><span class="pre">psq</span></code>-format.</p></li>
</ul>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>Select a specific name for the outfile, otherwise, the name of
the infile will be taken by default.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.align.sca.SCA">
<span class="sig-prename descclassname"><span class="pre">lingpy.align.sca.</span></span><span class="sig-name descname"><span class="pre">SCA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">infile</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.SCA" title="Permalink to this definition">¶</a></dt>
<dd><p>Method returns alignment objects depending on input file or input data.</p>
<p class="rubric">Notes</p>
<p>This method checks for the type of an alignment object and returns an
alignment object of the respective type.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lingpy.align.sca.get_consensus">
<span class="sig-prename descclassname"><span class="pre">lingpy.align.sca.</span></span><span class="sig-name descname"><span class="pre">get_consensus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taxa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.get_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a consensus string of a given MSA.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msa</strong> : {c{list} ~lingpy.align.multiple.Multiple}</p>
<blockquote>
<div><p>Either an MSA object or an MSA matrix.</p>
</div></blockquote>
<p><strong>gaps</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return the gap positions in the consensus.</p>
</div></blockquote>
<p><strong>taxa</strong> : {c{list} bool} (default=False)</p>
<blockquote>
<div><p>If <em>tree</em> is chosen as a parameter, specify the taxa in order of the aligned
strings.</p>
</div></blockquote>
<p><strong>classes</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>Specify whether sound classes shall be used to calculate the consensus.</p>
</div></blockquote>
<p><strong>model</strong> : ~lingpy.data.model.Model</p>
<blockquote>
<div><p>A sound class model according to which the IPA strings shall be
converted to sound-class strings.</p>
</div></blockquote>
<p><strong>local</strong> : { c{bool}, “peaks”, “gaps” }(default=False)</p>
<blockquote>
<div><p>Specify whether local pre-processing should be applied to the data. If
set to c{peaks}, the average alignment score of each column is taken as
reference to remove low-scoring columns from the alignment. If set to
“gaps”, the columns with the highest proportion of gaps will be
excluded.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cons</strong> : c{str}</p>
<blockquote>
<div><p>A consensus string of the given MSA.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-lingpy.align">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lingpy.align" title="Permalink to this headline">¶</a></h2>
<p>Package provides basic modules for alignment analyses.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/lingpy.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">lingpy.align package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-lingpy.align.multiple">lingpy.align.multiple module</a></li>
<li><a class="reference internal" href="#module-lingpy.align.pairwise">lingpy.align.pairwise module</a></li>
<li><a class="reference internal" href="#module-lingpy.align.sca">lingpy.align.sca module</a></li>
<li><a class="reference internal" href="#module-lingpy.align">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/lingpy.align.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
  <li><a href="../download.html">Download</a></li>

        <li class="nav-item nav-item-this"><a href="">lingpy.align package</a></li> 
      </ul>
    </div>
 <div id="footer" style="align-items:center;padding-top:5px;padding-left:0px;display:flex;justify-content:space-between;">

   <div>
     <a href="http://shh.mpg.de"><img width="60px" src="../_static/minerva.png" alt="MPG-SSH" /></a>
   </div>
  <div>
    <a href="http://dfg.de/"><img width="80px" src="../_static/dfg_logo_schwarz.jpg" alt="DFG" /></a>
  </div>

  <div style="max-width:300px;">
    <p style="font-size:70%">Created using <a href="http://sphinx-doc.org">Sphinx</a>. Last updated
    on Nov 26, 2021<br>
      This work is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by/4.0/">Creative
      Commons Attributio 4.0 International License</a>.</p>
    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" style="border-width:0;width:100px;"
		    src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a> </p>
  </div>

  <div>
    <a href="http://erc.europa.eu/"><img width="80px" src="../_static/European_Research_Council_logo.svg" alt="ERC" /></a>
  </div>
  <div style="max-width:150px;text-align:right;">
    <a href="http://github.com/lingpy/lingpy/">Application source on</a> 
    <a href="https://github.com/"><img width="100px" src="../_static/GitHub_Logo.png" alt="github logo" /></a>
</div>
</div>

  </body>
</html>