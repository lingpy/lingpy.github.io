<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>align Package &mdash; LingPy</title>
    
    <link rel="stylesheet" href="../_static/lingpy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="top" title="LingPy" href="../index.html" />
<link rel="stylesheet" type="text/css" href="_static/handheld.css" media="screen and (max-device-width: 720px)" />

  </head>
  <body>
<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
LingPy
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="align-package">
<h1>align Package<a class="headerlink" href="#align-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">align</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-lingpy.align"></span><p>Package provides basic modules for alignment analyses.</p>
</div>
<div class="section" id="module-lingpy.align.multiple">
<span id="multiple-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">multiple</span></tt> Module<a class="headerlink" href="#module-lingpy.align.multiple" title="Permalink to this headline">¶</a></h2>
<p>Module provides classes and functions for multiple alignment analyses.</p>
<dl class="class">
<dt id="lingpy.align.multiple.Multiple">
<em class="property">class </em><tt class="descclassname">lingpy.align.multiple.</tt><tt class="descname">Multiple</tt><big>(</big><em>seqs</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Basic class for multiple sequence alignment analyses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqs</strong> : list</p>
<blockquote class="last">
<div><p>List of sequences that shall be aligned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Depending on the structure of the sequences, further keywords can be
specified that manage how the items get tokenized.</p>
<dl class="method">
<dt id="lingpy.align.multiple.Multiple.get_local_peaks">
<tt class="descname">get_local_peaks</tt><big>(</big><em>threshold=2</em>, <em>gap_weight=0.0</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_local_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all peaks in a given alignment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>threshold</strong> : { int, float } (default=2)</p>
<blockquote>
<div><p>The threshold to determine whether a given column is a peak or not.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0.0)</p>
<blockquote class="last">
<div><p>The weight for gaps.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.get_pairwise_alignments">
<tt class="descname">get_pairwise_alignments</tt><big>(</big><em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_pairwise_alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Function creates a dictionary of all pairwise alignments  scores.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>new_calc</strong> : bool (default=True)</p>
<blockquote>
<div><p>Specify, whether the analysis should be repeated from the
beginning, or whether already conducted analyses should be carried
out.</p>
</div></blockquote>
<p><strong>model</strong> : string (default=&#8221;sca&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><tt class="xref py py-class docutils literal"><span class="pre">Model</span></tt></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li>&#8220;dolgo&#8221; &#8211; a sound-class model based on <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></tt>,</li>
<li>&#8220;sca&#8221; &#8211; an extension of the &#8220;dolgo&#8221; sound-class model based on
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></tt>, and</li>
<li>&#8220;asjp&#8221; &#8211; an independent sound-class model which is based on the
sound-class model of <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></tt> and the empirical data
of <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></tt> (see the description in
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></tt>.</li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : string (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></tt>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></tt>.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-3)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></tt>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=&#8221;T&#8221;)</p>
<blockquote class="last">
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></tt>) and
should therefore be aligned specifically. This defaults to &#8220;T&#8221;,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.get_peaks">
<tt class="descname">get_peaks</tt><big>(</big><em>gap_weight=0</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the profile score for each column of the alignment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>peaks</strong> : list</p>
<blockquote class="last">
<div><p>A list containing the profile scores for each column of the given
alignment.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.get_pid">
<tt class="descname">get_pid</tt><big>(</big><em>mode=1</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Percentage Identity (PID) score of the calculated MSA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mode</strong> : { 1, 2, 3, 4, 5 } (default=1)</p>
<blockquote>
<div><p>Indicate which of the four possible PID scores described in <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Raghava2006"><span class="pre">Raghava2006</span></a></tt>
should be calculated, the fifth possibility is added for linguistic
purposes:</p>
<ol class="arabic simple">
<li>identical positions / (aligned positions + internal gap positions),</li>
<li>identical positions / aligned positions,</li>
<li>identical positions / shortest sequence, or</li>
<li>identical positions / shortest sequence (including internal gap
pos.)</li>
<li>identical positions / (aligned positions + 2 * number of gaps)</li>
</ol>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>score</strong> : float</p>
<blockquote class="last">
<div><p>The PID score of the given alignment as a floating point number between
0 and 1.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="lingpy.sequence.html#lingpy.sequence.sound_classes.pid" title="lingpy.sequence.sound_classes.pid"><tt class="xref py py-obj docutils literal"><span class="pre">lingpy.sequence.sound_classes.pid</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.iterate_all_sequences">
<tt class="descname">iterate_all_sequences</tt><big>(</big><em>check='final'</em>, <em>mode='global'</em>, <em>gop=-3</em>, <em>scale=0.5</em>, <em>factor=0</em>, <em>gap_weight=1</em>, <em>restricted_chars='T_'</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterative refinement based on a complete realignment of all sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>check</strong> : { &#8220;final&#8221;, &#8220;immediate&#8221; } (default=&#8221;final&#8221;)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (&#8220;immediate&#8221;) or after all iterations have been carried
out (&#8220;final&#8221;).</p>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;overlap&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></tt>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></tt>.</li>
<li>&#8220;overlap&#8221; &#8211; semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1981"><span class="pre">Gotoh1981</span></a></tt>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote class="last">
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="lingpy.align.multiple.Multiple.iterate_clusters"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_clusters</span></tt></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="lingpy.align.multiple.Multiple.iterate_similar_gap_sites"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_similar_gap_sites</span></tt></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_orphans" title="lingpy.align.multiple.Multiple.iterate_orphans"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_orphans</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method essentially follows the iterative method of
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Barton1987"><span class="pre">Barton1987</span></a></tt> with the exception that an MSA has already been
calculated.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.iterate_clusters">
<tt class="descname">iterate_clusters</tt><big>(</big><em>threshold</em>, <em>check='final'</em>, <em>mode='global'</em>, <em>gop=-3</em>, <em>scale=0.5</em>, <em>factor=0</em>, <em>gap_weight=1</em>, <em>restricted_chars='T_'</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterative refinement based on a flat cluster analysis of the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>threshold</strong> : float</p>
<blockquote>
<div><p>The threshold for the flat cluster analysis.</p>
</div></blockquote>
<p><strong>check</strong> : string (default=&#8221;final&#8221;)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (&#8220;immediate&#8221;) or after all iterations have been carried
out (&#8220;final&#8221;).</p>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;overlap&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8216;global&#8217; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></tt>,</li>
<li>&#8216;dialign&#8217; &#8211; global alignment analysis which seeks to maximize
local similarities <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></tt>.</li>
<li>&#8216;overlap&#8217; &#8211; semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1981"><span class="pre">Gotoh1981</span></a></tt>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote class="last">
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="lingpy.align.multiple.Multiple.iterate_similar_gap_sites"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_similar_gap_sites</span></tt></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="lingpy.align.multiple.Multiple.iterate_all_sequences"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_all_sequences</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method uses the <a class="reference internal" href="lingpy.algorithm.html#lingpy.algorithm.clustering.flat_upgma" title="lingpy.algorithm.clustering.flat_upgma"><tt class="xref py py-func docutils literal"><span class="pre">lingpy.algorithm.clustering.flat_upgma()</span></tt></a>
function in order to retrieve a flat cluster of the data.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.iterate_orphans">
<tt class="descname">iterate_orphans</tt><big>(</big><em>check='final'</em>, <em>mode='global'</em>, <em>gop=-3</em>, <em>scale=0.5</em>, <em>factor=0</em>, <em>gap_weight=1.0</em>, <em>restricted_chars='T_'</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_orphans" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the most divergent sequences in the sample.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>check</strong> : string (default=&#8221;final&#8221;)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (&#8220;immediate&#8221;) or after all iterations have been carried
out (&#8220;final&#8221;).</p>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;overlap&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></tt>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></tt>.</li>
<li>&#8220;overlap&#8221; &#8211; semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1981"><span class="pre">Gotoh1981</span></a></tt>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote class="last">
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="lingpy.align.multiple.Multiple.iterate_clusters"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_clusters</span></tt></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="lingpy.align.multiple.Multiple.iterate_similar_gap_sites"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_similar_gap_sites</span></tt></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="lingpy.align.multiple.Multiple.iterate_all_sequences"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_all_sequences</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>The most divergent sequences are those whose average distance to all
other sequences is above the average distance of all sequence pairs.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.iterate_similar_gap_sites">
<tt class="descname">iterate_similar_gap_sites</tt><big>(</big><em>check='final'</em>, <em>mode='global'</em>, <em>gop=-3</em>, <em>scale=0.5</em>, <em>factor=0</em>, <em>gap_weight=1</em>, <em>restricted_chars='T_'</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterative refinement based on the <em>Similar Gap Sites</em> heuristic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>check</strong> : { &#8220;final&#8221;, &#8220;immediate&#8221; } (default=&#8221;final&#8221;)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (&#8220;immediate&#8221;) or after all iterations have been carried
out (&#8220;final&#8221;).</p>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;overlap&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8216;global&#8217; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></tt>,</li>
<li>&#8216;dialign&#8217; &#8211; global alignment analysis which seeks to maximize
local similarities <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></tt>.</li>
<li>&#8216;overlap&#8217; &#8211; semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></tt>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=1)</p>
<blockquote class="last">
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When, e.g., set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="lingpy.align.multiple.Multiple.iterate_clusters"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_clusters</span></tt></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="lingpy.align.multiple.Multiple.iterate_all_sequences"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_all_sequences</span></tt></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_orphans" title="lingpy.align.multiple.Multiple.iterate_orphans"><tt class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_orphans</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>This heuristic is fairly simple. The idea is to try to split a given
MSA into partitions with identical gap sites.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.lib_align">
<tt class="descname">lib_align</tt><big>(</big><em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.lib_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a library-based progressive alignment analysis of the sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : { &#8220;dolgo&#8221;, &#8220;sca&#8221;, &#8220;asjp&#8221; } (default=&#8221;sca&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><tt class="xref py py-class docutils literal"><span class="pre">Model</span></tt></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li>&#8220;dolgo&#8221; &#8211; a sound-class model based on <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></tt>,</li>
<li>&#8220;sca&#8221; &#8211; an extension of the &#8220;dolgo&#8221; sound-class model based on
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></tt>, and</li>
<li>&#8220;asjp&#8221; &#8211; an independent sound-class model which is based on the
sound-class model of <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></tt> and the empirical data
of <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></tt> (see the description in
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></tt>.</li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></tt>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></tt>.</li>
</ul>
</div></blockquote>
<p><strong>modes</strong> : list (default=[(&#8220;global&#8221;,-10,0.6),(&#8220;local&#8221;,-1,0.6)])</p>
<blockquote>
<div><p>Indicate the mode, the gap opening penalties (GOP), and the gap extension scale
(GEP scale), of the pairwise alignment analyses which
are used to create the library.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></tt>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { &#8220;neighbor&#8221;, &#8220;upgma&#8221; } (default=&#8221;upgma&#8221;)</p>
<blockquote>
<div><p>The cluster algorithm which shall be used for the calculation of
the guide tree. Select between <tt class="docutils literal"><span class="pre">neighbor</span></tt>, the Neighbor-Joining
algorithm (<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Saitou1987"><span class="pre">Saitou1987</span></a></tt>), and <tt class="docutils literal"><span class="pre">upgma</span></tt>, the UPGMA
algorithm (<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></tt>).</p>
</div></blockquote>
<p><strong>guide_tree</strong> : tree_matrix</p>
<blockquote>
<div><p>Use a custom guide tree instead of performing a cluster algorithm
for constructing one based on the input similarities. The use of this
option makes the tree_calc option irrelevant.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=&#8221;T&#8221;)</p>
<blockquote class="last">
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></tt>) and
should therefore be aligned specifically. This defaults to &#8220;T&#8221;,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In contrast to traditional progressive multiple sequence alignment
approaches such as <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Feng1981"><span class="pre">Feng1981</span></a></tt> and <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Thompson1994"><span class="pre">Thompson1994</span></a></tt>,
library-based progressive alignment <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Notredame2000"><span class="pre">Notredame2000</span></a></tt> is based on
a pre-processing of the data where the information given in global and
local pairwise alignments of the input sequences is used to derive a
refined scoring function (<em>library</em>) which is later used in the
progressive phase.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.prog_align">
<tt class="descname">prog_align</tt><big>(</big><em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.prog_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a progressive alignment analysis of the input sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : { &#8220;dolgo&#8221;, &#8220;sca&#8221;, &#8220;asjp&#8221; } (defaul=&#8221;sca&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><tt class="xref py py-class docutils literal"><span class="pre">Model</span></tt></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li>&#8220;dolgo&#8221; &#8211; a sound-class model based on <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></tt>,</li>
<li>&#8220;sca&#8221; &#8211; an extension of the &#8220;dolgo&#8221; sound-class model based on
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></tt>, and</li>
<li>&#8220;asjp&#8221; &#8211; an independent sound-class model which is based on the
sound-class model of <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></tt> and the empirical data
of <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></tt> (see the description in
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></tt>.</li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></tt>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></tt>.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></tt>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { &#8220;neighbor&#8221;, &#8220;upgma&#8221; } (default=&#8221;upgma&#8221;)</p>
<blockquote>
<div><p>The cluster algorithm which shall be used for the calculation of
the guide tree. Select between <tt class="docutils literal"><span class="pre">neighbor</span></tt>, the Neighbor-Joining
algorithm (<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Saitou1987"><span class="pre">Saitou1987</span></a></tt>), and <tt class="docutils literal"><span class="pre">upgma</span></tt>, the UPGMA
algorithm (<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></tt>).</p>
</div></blockquote>
<p><strong>guide_tree</strong> : tree_matrix</p>
<blockquote>
<div><p>Use a custom guide tree instead of performing a cluster algorithm
for constructing one based on the input similarities. The use of this
option makes the tree_calc option irrelevant.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=&#8221;T&#8221;)</p>
<blockquote class="last">
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></tt>) and
should therefore be aligned specifically. This defaults to &#8220;T&#8221;,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.sum_of_pairs">
<tt class="descname">sum_of_pairs</tt><big>(</big><em>alm_matrix='self'</em>, <em>mat=None</em>, <em>gap_weight=0.0</em>, <em>gop=-1</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.sum_of_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the sum-of-pairs score for a given alignment analysis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>alm_matrix</strong> : { &#8220;self&#8221;, &#8220;other&#8221; } (default=&#8221;self&#8221;)</p>
<blockquote>
<div><p>Indicate for which MSA the sum-of-pairs score shall be calculated.</p>
</div></blockquote>
<p><strong>mat</strong> : { None, list }</p>
<blockquote>
<div><p>If &#8220;other&#8221; is chosen as an option for <strong>alm_matrix</strong>, define for
which matrix the sum-of-pairs score shall be calculated.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>The sum-of-pairs score of the alignment.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.swap_check">
<tt class="descname">swap_check</tt><big>(</big><em>swap_penalty=-3</em>, <em>score_mode='classes'</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.Multiple.swap_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for possibly swapped sites in the alignment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>swap_penalty</strong> : { int, float } (default=-3)</p>
<blockquote>
<div><p>Specify the penalty for swaps in the alignment.</p>
</div></blockquote>
<p><strong>score_mode</strong> : { &#8220;classes&#8221;, &#8220;library&#8221; } (default=&#8221;classes&#8221;)</p>
<blockquote>
<div><p>Define the score-mode of the calculation which is either based on
sound classes proper, or on the specific scores derived from the
library approach.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : bool</p>
<blockquote class="last">
<div><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt>, if a swap was identified, and <tt class="docutils literal"><span class="pre">False</span></tt>
otherwise. The information regarding the position of the swap is
stored in the attribute <tt class="docutils literal"><span class="pre">swap_index</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The method for swap detection is described in detail in <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></tt>.</p>
<p class="rubric">Examples</p>
<p>Define a set of strings whose alignment contans a swap.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span> <span class="o">=</span> <span class="n">Multiple</span><span class="p">([</span><span class="s">&quot;woldemort&quot;</span><span class="p">,</span> <span class="s">&quot;waldemar&quot;</span><span class="p">,</span> <span class="s">&quot;wladimir&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Align the data, using the progressive approach.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span><span class="o">.</span><span class="n">prog_align</span><span class="p">()</span>
</pre></div>
</div>
<p>Check for swaps.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span><span class="o">.</span><span class="n">swap_check</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Print the alignment</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
<span class="go">w   o   l   -   d   e   m   o   r   t</span>
<span class="go">w   a   l   -   d   e   m   a   r   -</span>
<span class="go">v   -   l   a   d   i   m   i   r   -</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingpy.align.multiple.mult_align">
<tt class="descclassname">lingpy.align.multiple.</tt><tt class="descname">mult_align</tt><big>(</big><em>seqs</em>, <em>gop=-1</em>, <em>scale=0.5</em>, <em>tree_calc='upgma'</em>, <em>pprint=False</em><big>)</big><a class="headerlink" href="#lingpy.align.multiple.mult_align" title="Permalink to this definition">¶</a></dt>
<dd><p>A short-cut method for multiple alignment analyses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqs</strong> : list</p>
<blockquote>
<div><p>The input sequences.</p>
</div></blockquote>
<p><strong>gop = int (default=-1)</strong> :</p>
<blockquote>
<div><p>The gap opening penalty.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The scaling factor by which penalties for gap extensions are decreased.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { &#8220;upgma&#8221; &#8220;neighbor&#8221; } (default=&#8221;upgma&#8221;)</p>
<blockquote>
<div><p>The algorithm which is used for the calculation of the guide tree.</p>
</div></blockquote>
<p><strong>pprint</strong> : bool (default=False)</p>
<blockquote>
<div><p>Indicate whether results shall be printed onto screen.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>alignments</strong> : list</p>
<blockquote class="last">
<div><p>A two-dimensional list in which alignments are represented as a list of
tokens.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">mult_align</span><span class="p">([</span><span class="s">&quot;woldemort&quot;</span><span class="p">,</span> <span class="s">&quot;waldemar&quot;</span><span class="p">,</span> <span class="s">&quot;vladimir&quot;</span><span class="p">],</span> <span class="n">pprint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">w   o   l   -   d   e   m   o   r   t</span>
<span class="go">w   a   l   -   d   e   m   a   r   -</span>
<span class="go">-   v   l   a   d   i   m   i   r   -</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-lingpy.align.pairwise">
<span id="pairwise-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">pairwise</span></tt> Module<a class="headerlink" href="#module-lingpy.align.pairwise" title="Permalink to this headline">¶</a></h2>
<p>Module provides classes and functions for pairwise alignment analyses.</p>
<dl class="class">
<dt id="lingpy.align.pairwise.Pairwise">
<em class="property">class </em><tt class="descclassname">lingpy.align.pairwise.</tt><tt class="descname">Pairwise</tt><big>(</big><em>seqs</em>, <em>seqB=False</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.pairwise.Pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Basic class for the handling of pairwise sequence alignments (PSA).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqs</strong> : string list</p>
<blockquote>
<div><p>Either the first string of a sequence pair that shall be aligned,
or a list of sequence tuples.</p>
</div></blockquote>
<p><strong>seqB</strong> : string or bool (default=None)</p>
<blockquote class="last">
<div><p>Define the second sequence that shall be aligned with the first
sequence, if only two sequences shall be compared.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lingpy.align.pairwise.Pairwise.align">
<tt class="descname">align</tt><big>(</big><em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.pairwise.Pairwise.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a pair of sequences or multiple sequence pairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gop</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap opening penalty (GOP).</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The gap extension penalty (GEP), calculated with help of a scaling
factor.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8220;global&#8221;,&#8221;local&#8221;,&#8221;overlap&#8221;,&#8221;dialign&#8221;}</p>
<blockquote>
<div><p>The alignment mode, see <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></tt> for details.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default = 0.3)</p>
<blockquote>
<div><p>The factor by which matches in identical prosodic position are
increased.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : str (default=&#8221;<a href="#id2"><span class="problematic" id="id3">T_</span></a>&#8221;)</p>
<blockquote>
<div><p>The restricted chars that function as an indicator of syllable or
morpheme breaks for secondary alignment, see <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012c"><span class="pre">List2012c</span></a></tt>
for details.</p>
</div></blockquote>
<p><strong>distance</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to <em>True</em>, return the distance instead of the similarity
score. Distance is calculated using the formula by
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Downey2008"><span class="pre">Downey2008</span></a></tt>.</p>
</div></blockquote>
<p><strong>model</strong> : { None, ~lingpy.data.model.Model }</p>
<blockquote>
<div><p>Specify the sound class model that shall be used for the analysis.
If no model is specified, the default model of <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></tt>
will be used.</p>
</div></blockquote>
<p><strong>pprint</strong> : bool (default=False)</p>
<blockquote class="last">
<div><p>If set to <em>True</em>, the alignments are printed to the screen.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.edit_dist">
<tt class="descclassname">lingpy.align.pairwise.</tt><tt class="descname">edit_dist</tt><big>(</big><em>seqA</em>, <em>seqB</em>, <em>normalized=False</em>, <em>restriction=''</em><big>)</big><a class="headerlink" href="#lingpy.align.pairwise.edit_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edit distance between two strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA,seqB</strong> : str</p>
<blockquote>
<div><p>The strings that shall be compared.</p>
</div></blockquote>
<p><strong>normalized</strong> : bool (default=False)</p>
<blockquote>
<div><p>Specify whether the normalized edit distance shall be returned. If no
restrictions are chosen, the edit distance is normalized by dividing by
the length of the longer string. If <em>restriction</em> is set to <em>cv</em>
(consonant-vowel), the edit distance is normalized by the length of the
alignment.</p>
</div></blockquote>
<p><strong>restriction</strong> : {&#8220;cv&#8221;} (default=&#8221;&#8221;)</p>
<blockquote>
<div><p>Specify the restrictions to be used. Currently, only <tt class="docutils literal"><span class="pre">cv</span></tt> is
supported. This prohibits matches of vowels with consonants.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dist</strong> : {int float}</p>
<blockquote class="last">
<div><p>The edit distance, which is a float if normalized is set to c{True},
and an integer otherwise.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The edit distance was first formally defined by V. I. Levenshtein
(<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Levenshtein1965"><span class="pre">Levenshtein1965</span></a></tt>). The first algorithm to compute the edit
distance was proposed by Wagner and Fisher (<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Wagner1974"><span class="pre">Wagner1974</span></a></tt>).</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setB</span> <span class="o">=</span> <span class="s">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edit_dist</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span><span class="n">seqB</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.nw_align">
<tt class="descclassname">lingpy.align.pairwise.</tt><tt class="descname">nw_align</tt><big>(</big><em>seqA</em>, <em>seqB</em>, <em>scorer=False</em>, <em>gap=-1</em><big>)</big><a class="headerlink" href="#lingpy.align.pairwise.nw_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out the traditional Needleman-Wunsch algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>scorer</strong> : dict (default=False)</p>
<blockquote>
<div><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings.</p>
</div></blockquote>
<p><strong>gap</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap penalty.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>alm</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple consisting of the aligments of the first and the second
sequence, and the alignment score.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Needleman-Wunsch algorithm (see <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></tt>) returns a global
alignment of two sequences.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setB</span> <span class="o">=</span> <span class="s">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span><span class="n">seqB</span><span class="p">)</span>
<span class="go">([&#39;f&#39;, &#39;a&#39;, &#39;t&#39;, &#39; &#39;, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;c&#39;, &#39;a&#39;, &#39;t&#39;, &#39;-&#39;, &#39;f&#39;, &#39;a&#39;, &#39;t&#39;], 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.pw_align">
<tt class="descclassname">lingpy.align.pairwise.</tt><tt class="descname">pw_align</tt><big>(</big><em>seqA</em>, <em>seqB</em>, <em>gop=-1</em>, <em>scale=0.5</em>, <em>scorer=False</em>, <em>mode='global'</em>, <em>distance=False</em><big>)</big><a class="headerlink" href="#lingpy.align.pairwise.pw_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align two sequences in various ways.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>scorer</strong> : dict (default=False)</p>
<blockquote>
<div><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap opening penalty.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The gap extension scale. This scale is similar to the gap extension
penalty, but in contrast to the traditional GEP, it &#8220;scales&#8221; the gap
opening penalty.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8220;global&#8221;, &#8220;local&#8221;, &#8220;diagonal&#8221;, &#8220;overlap&#8221;} (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>Select between one of the four different alignment modes regularly
implemented in LingPy, see <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></tt> for details.</p>
</div></blockquote>
<p><strong>distance</strong> : bool (default=False)</p>
<blockquote class="last">
<div><p>If set to c{True} return the distance score following the formula by
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Downey2008"><span class="pre">Downey2008</span></a></tt>. Otherwise, return the basic similarity score.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setB</span> <span class="o">=</span> <span class="s">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;dialign&#39;</span><span class="p">)</span>
<span class="go">([&#39;f&#39;, &#39;a&#39;, &#39;t&#39;, &#39; &#39;, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;],</span>
<span class="go"> [&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;, &#39;f&#39;, &#39;a&#39;, &#39;t&#39;],</span>
<span class="go"> 3.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.structalign">
<tt class="descclassname">lingpy.align.pairwise.</tt><tt class="descname">structalign</tt><big>(</big><em>seqA</em>, <em>seqB</em><big>)</big><a class="headerlink" href="#lingpy.align.pairwise.structalign" title="Permalink to this definition">¶</a></dt>
<dd><p>Experimental function for testing structural alignment algorithms.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.sw_align">
<tt class="descclassname">lingpy.align.pairwise.</tt><tt class="descname">sw_align</tt><big>(</big><em>seqA</em>, <em>seqB</em>, <em>scorer=False</em>, <em>gap=-1</em><big>)</big><a class="headerlink" href="#lingpy.align.pairwise.sw_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out the traditional Smith-Waterman algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>scorer</strong> : dict (default=False)</p>
<blockquote>
<div><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings.</p>
</div></blockquote>
<p><strong>gap</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap penalty.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>alm</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple consisting of prefix, alignment, and suffix of the first and
the second sequence, and the alignment score.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Smith-Waterman algorithm (see <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Smith1981"><span class="pre">Smith1981</span></a></tt>) returns a local
alignment between two sequences. A local alignment is an alignment of those
subsequences of the input sequences that yields the highest score.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setB</span> <span class="o">=</span> <span class="s">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span><span class="n">seqB</span><span class="p">)</span>
<span class="go">(([], [&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], [&#39; &#39;, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;]),</span>
<span class="go"> ([&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], []),</span>
<span class="go"> 3.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.turchin">
<tt class="descclassname">lingpy.align.pairwise.</tt><tt class="descname">turchin</tt><big>(</big><em>seqA</em>, <em>seqB</em>, <em>model='dolgo'</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.pairwise.turchin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cognate judgment based on the method by <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Turchin2010"><span class="pre">Turchin2010</span></a></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>model</strong> : {&#8220;asjp&#8221;, &#8220;sca&#8221;, &#8220;dolgo&#8221;} (default=&#8221;dolgo&#8221;)</p>
<blockquote>
<div><p>A sound-class model instance or a string that denotes one of the
standard sound class models used in LingPy.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cognacy</strong> : {0, 1}</p>
<blockquote class="last">
<div><p>The cognacy assertion which is either 0 (words are probably cognate) or
1 (words are not likely to be cognate).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.we_align">
<tt class="descclassname">lingpy.align.pairwise.</tt><tt class="descname">we_align</tt><big>(</big><em>seqA</em>, <em>seqB</em>, <em>scorer=False</em>, <em>gap=-1</em><big>)</big><a class="headerlink" href="#lingpy.align.pairwise.we_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out the traditional Waterman-Eggert algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>scorer</strong> : dict (default=False)</p>
<blockquote>
<div><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings.</p>
</div></blockquote>
<p><strong>gap</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap penalty.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>alms</strong> : list</p>
<blockquote class="last">
<div><p>A list consisting of tuples. Each tuple gives the alignment of one of
the subsequences of the input sequences. Each tuple contains the
aligned part of the first, the aligned part of the second sequence, and
the score of the alignment.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Waterman-Eggert algorithm (see <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Waterman1987"><span class="pre">Waterman1987</span></a></tt>) returns <em>all</em>
local matches between two sequences.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setB</span> <span class="o">=</span> <span class="s">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">we_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span><span class="n">seqB</span><span class="p">)</span>
<span class="go">[([&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], 3.0),</span>
<span class="go"> ([&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], 3.0)]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-lingpy.align.sca">
<span id="sca-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">sca</span></tt> Module<a class="headerlink" href="#module-lingpy.align.sca" title="Permalink to this headline">¶</a></h2>
<p>Basic module for pairwise and multiple sequence comparison.</p>
<p>The module consists of four classes which deal with pairwise and multiple
sequence comparison from the <em>sequence</em> and the <em>alignment</em> perspective. The
sequence perspective deals with unaligned sequences. The <em>alignment</em>
perspective deals with aligned sequences.</p>
<dl class="class">
<dt id="lingpy.align.sca.Alignments">
<em class="property">class </em><tt class="descclassname">lingpy.align.sca.</tt><tt class="descname">Alignments</tt><big>(</big><em>infile</em>, <em>row='concept'</em>, <em>col='doculect'</em>, <em>conf=''</em>, <em>ref='cogid'</em>, <em>loans=True</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.Alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingpy.basic.html#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><tt class="xref py py-class docutils literal"><span class="pre">lingpy.basic.wordlist.Wordlist</span></tt></a></p>
<p>Class handles Wordlists for the purpose of alignment analyses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>infile</strong> : str</p>
<blockquote>
<div><p>The name of the input file that should conform to the basic format of
the <cite>~lingpy.basic.wordlist.Wordlist</cite> class and define a specific ID
for cognate sets.</p>
</div></blockquote>
<p><strong>row</strong> : str (default = &#8220;concept&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the row that shall be taken as the
basis for the tabular representation of the word list.</p>
</div></blockquote>
<p><strong>col</strong> : str (default = &#8220;doculect&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the column that shall be taken as the
basis for the tabular representation of the word list.</p>
</div></blockquote>
<p><strong>conf</strong> : string (default=&#8217;&#8216;)</p>
<blockquote>
<div><p>A string defining the path to the configuration file.</p>
</div></blockquote>
<p><strong>ref</strong> : string (default=&#8217;cogid&#8217;)</p>
<blockquote>
<div><p>The name of the column that stores the cognate IDs.</p>
</div></blockquote>
<p><strong>loans</strong> : bool (default=True)</p>
<blockquote class="last">
<div><p>Specify whether loans should be included in the cognate sets.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This class inherits from <a class="reference internal" href="lingpy.basic.html#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><tt class="xref py py-class docutils literal"><span class="pre">Wordlist</span></tt></a> and
additionally creates instances of the
<a class="reference internal" href="#lingpy.align.multiple.Multiple" title="lingpy.align.multiple.Multiple"><tt class="xref py py-class docutils literal"><span class="pre">Multiple</span></tt></a> class for all cognate sets that
are specified by the <em>ref</em> keyword.</p>
<dl class="method">
<dt id="lingpy.align.sca.Alignments.align">
<tt class="descname">align</tt><big>(</big><em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.Alignments.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a multiple alignment analysis of the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : { &#8220;progressive&#8221;, &#8220;library&#8221; } (default=&#8221;progressive&#8221;)</p>
<blockquote>
<div><p>Select the method to use for the analysis.</p>
</div></blockquote>
<p><strong>iteration</strong> : bool (default=False)</p>
<blockquote>
<div><p>Set to c{True} in order to use iterative refinement methods.</p>
</div></blockquote>
<p><strong>swap_check</strong> : bool (default=False)</p>
<blockquote>
<div><p>Set to c{True} in order to carry out a swap-check.</p>
</div></blockquote>
<p><strong>output</strong> : bool (default=False)</p>
<blockquote>
<div><p>Set to c{True} in order to write all alignments to file.</p>
</div></blockquote>
<p><strong>model</strong> : { &#8216;dolgo&#8217;, &#8216;sca&#8217;, &#8216;asjp&#8217; }</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><tt class="xref py py-class docutils literal"><span class="pre">Model</span></tt></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li>&#8220;dolgo&#8221; &#8211; a sound-class model based on <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></tt>,</li>
<li>&#8220;sca&#8221; &#8211; an extension of the &#8220;dolgo&#8221; sound-class model based on
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></tt>, and</li>
<li>&#8220;asjp&#8221; &#8211; an independent sound-class model which is based on the
sound-class model of <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></tt> and the empirical data
of <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></tt> (see the description in
<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></tt>.</li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : { &#8216;global&#8217;, &#8216;dialign&#8217; }</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></tt>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></tt>.</li>
</ul>
</div></blockquote>
<p><strong>modes</strong> : list (default=[(&#8216;global&#8217;,-2,0.5),(&#8216;local&#8217;,-1,0.5)])</p>
<blockquote>
<div><p>Indicate the mode, the gap opening penalties (GOP), and the gap
extension scale (GEP scale), of the pairwise alignment analyses
which are used to create the library.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></tt>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { &#8216;neighbor&#8217;, &#8216;upgma&#8217; } (default=&#8217;upgma&#8217;)</p>
<blockquote>
<div><p>The cluster algorithm which shall be used for the calculation of
the guide tree. Select between <tt class="docutils literal"><span class="pre">neighbor</span></tt>, the Neighbor-Joining
algorithm (<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Saitou1987"><span class="pre">Saitou1987</span></a></tt>), and <tt class="docutils literal"><span class="pre">upgma</span></tt>, the UPGMA
algorithm (<tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></tt>).</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=&#8221;T&#8221;)</p>
<blockquote class="last">
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <tt class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></tt>) and
should therefore be aligned specifically. This defaults to &#8220;T&#8221;,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.sca.Alignments.get_confidence">
<tt class="descname">get_confidence</tt><big>(</big><em>scorer</em>, <em>ref='lexstatid'</em>, <em>gap_weight=0.25</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.Alignments.get_confidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Function creates confidence scores for a given set of alignments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scorer</strong> : <tt class="xref py py-class docutils literal"><span class="pre">ScoreDict</span></tt></p>
<blockquote>
<div><p>A <em>ScoreDict</em> object which gives similarity scores for all segments in
the alignment.</p>
</div></blockquote>
<p><strong>ref</strong> : str (default=&#8221;lexstatid&#8221;)</p>
<blockquote>
<div><p>The reference entry-type, referring to the cognate-set to be used for
the analysis.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : {loat} (default=1.0)</p>
<blockquote class="last">
<div><p>Determine the weight assigned to matches containing gaps.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.sca.Alignments.get_consensus">
<tt class="descname">get_consensus</tt><big>(</big><em>tree=False</em>, <em>gaps=False</em>, <em>classes=False</em>, <em>consensus='consensus'</em>, <em>counterpart='ipa'</em>, <em>weights=</em>, <span class="optional">[</span><span class="optional">]</span><em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.Alignments.get_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a consensus string of all MSAs in the wordlist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>msa</strong> : {c{list} ~lingpy.align.multiple.Multiple}</p>
<blockquote>
<div><p>Either an MSA object or an MSA matrix.</p>
</div></blockquote>
<p><strong>tree</strong> : {c{str} ~lingpy.thirdparty.cogent.PhyloNode}</p>
<blockquote>
<div><p>A tree object or a Newick string along which the consensus shall be
calculated.</p>
</div></blockquote>
<p><strong>gaps</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return the gap positions in the consensus.</p>
</div></blockquote>
<p><strong>classes</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>Specify whether sound classes shall be used to calculate the consensus.</p>
</div></blockquote>
<p><strong>model</strong> : ~lingpy.data.model.Model</p>
<blockquote class="last">
<div><p>A sound class model according to which the IPA strings shall be
converted to sound-class strings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.sca.Alignments.output">
<tt class="descname">output</tt><big>(</big><em>fileformat</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.Alignments.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write wordlist to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileformat</strong> : {&#8220;qlc&#8221;, &#8220;tre&#8221;,&#8221;nwk&#8221;,&#8221;dst&#8221;, &#8220;taxa&#8221;, &#8220;starling&#8221;, &#8220;paps.nex&#8221;, &#8220;paps.csv&#8221; &#8220;html&#8221;}</p>
<blockquote>
<div><p>The format that is written to file. This corresponds to the file
extension, thus &#8216;csv&#8217; creates a file in csv-format, &#8216;dst&#8217; creates
a file in Phylip-distance format, etc.</p>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>Specify the name of the output file (defaults to a filename that
indicates the creation date).</p>
</div></blockquote>
<p><strong>subset</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return only a subset of the data. Which subset
is specified in the keywords &#8216;cols&#8217; and &#8216;rows&#8217;.</p>
</div></blockquote>
<p><strong>cols</strong> : list</p>
<blockquote>
<div><p>If <em>subset</em> is set to c{True}, specify the columns that shall be
written to the csv-file.</p>
</div></blockquote>
<p><strong>rows</strong> : dict</p>
<blockquote>
<div><p>If <em>subset</em> is set to c{True}, use a dictionary consisting of keys
that specify a column and values that give a Python-statement in
raw text, such as, e.g., &#8220;== &#8216;hand&#8217;&#8221;. The content of the specified
column will then be checked against statement passed in the
dictionary, and if it is evaluated to c{True}, the respective row
will be written to file.</p>
</div></blockquote>
<p><strong>cognates</strong> : str</p>
<blockquote>
<div><p>Name of the column that contains the cognate IDs if &#8216;starling&#8217; is
chosen as an output format.</p>
</div></blockquote>
<p><strong>missing</strong> : { str, int } (default=0)</p>
<blockquote>
<div><p>If &#8216;paps.nex&#8217; or &#8216;paps.csv&#8217; is chosen as fileformat, this character
will be inserted as an indicator of missing data.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : {&#8216;neighbor&#8217;, &#8216;upgma&#8217;}</p>
<blockquote>
<div><p>If no tree has been calculated and &#8216;tre&#8217; or &#8216;nwk&#8217; is chosen as
output format, the method that is used to calculate the tree.</p>
</div></blockquote>
<p><strong>threshold</strong> : float (default=0.6)</p>
<blockquote class="last">
<div><p>The threshold that is used to carry out a flat cluster analysis if
&#8216;groups&#8217; or &#8216;cluster&#8217; is chosen as output format.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingpy.align.sca.MSA">
<em class="property">class </em><tt class="descclassname">lingpy.align.sca.</tt><tt class="descname">MSA</tt><big>(</big><em>infile</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.MSA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.align.multiple.Multiple" title="lingpy.align.multiple.Multiple"><tt class="xref py py-class docutils literal"><span class="pre">lingpy.align.multiple.Multiple</span></tt></a></p>
<p>Basic class for carrying out multiple sequence alignment analyses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>infile</strong> : file</p>
<blockquote>
<div><p>A file in <tt class="docutils literal"><span class="pre">msq</span></tt>-format or <tt class="docutils literal"><span class="pre">msa</span></tt>-format.</p>
</div></blockquote>
<p><strong>merge_vowels</strong> : bool (default=True)</p>
<blockquote>
<div><p>Indicate, whether neighboring vowels should be merged into
diphtongs, or whether they should be kept separated during the
analysis.</p>
</div></blockquote>
<p><strong>comment</strong> : char (default=&#8217;#&#8217;)</p>
<blockquote class="last">
<div><p>The comment character which, inserted in the beginning of a line,
prevents that line from being read.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>There are two possible input formats for this class: the MSQ-format, and
the MSA-format (see <a class="reference internal" href="../tutorial/formats.html#msa-formats"><em>Multiple Alignments (MSQ and MSA)</em></a> for details). This class directly
inherits all methods of the <a class="reference internal" href="#lingpy.align.multiple.Multiple" title="lingpy.align.multiple.Multiple"><tt class="xref py py-class docutils literal"><span class="pre">Multiple</span></tt></a>
class.</p>
<p class="rubric">Examples</p>
<p>Get the path to a file from the testset.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">rc</span><span class="p">(</span><span class="s">&quot;test_path&quot;</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;harry.msq&#39;</span>
</pre></div>
</div>
<p>Load the file into the Multiple class.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span> <span class="o">=</span> <span class="n">Multiple</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>
</div>
<p>Carry out a progressive alignment analysis of the sequences.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span><span class="o">.</span><span class="n">prog_align</span><span class="p">()</span>
</pre></div>
</div>
<p>Print the result to the screen:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
<span class="go">w    o    l    -    d    e    m    o    r    t</span>
<span class="go">w    a    l    -    d    e    m    a    r    -</span>
<span class="go">v    -    l    a    d    i    m    i    r    -</span>
</pre></div>
</div>
<dl class="method">
<dt id="lingpy.align.sca.MSA.ipa2cls">
<tt class="descname">ipa2cls</tt><big>(</big><em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.MSA.ipa2cls" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve sound-class strings from aligned IPA sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : str (default=&#8217;sca&#8217;)</p>
<blockquote class="last">
<div><p>The sound-class model according to which the sequences shall be
converted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is only useful when an <tt class="docutils literal"><span class="pre">msa</span></tt>-file with already
conducted alignment analyses was loaded.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.sca.MSA.output">
<tt class="descname">output</tt><big>(</big><em>fileformat='msa'</em>, <em>filename=None</em>, <em>sorted_seqs=False</em>, <em>unique_seqs=False</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.MSA.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileformat</strong> : { &#8220;psa&#8221;, &#8220;msa&#8221;, &#8220;msq&#8221; }</p>
<blockquote>
<div><p>Indicate which data should be written to file. Select between:</p>
<ul class="simple">
<li>&#8220;psa&#8221; &#8211; output of all pairwise alignments in <tt class="docutils literal"><span class="pre">psa</span></tt>-format,</li>
<li>&#8220;msa&#8221; &#8211; output of the multiple alignment in <tt class="docutils literal"><span class="pre">msa</span></tt>-format, or</li>
<li>&#8220;msq&#8221; &#8211; output of the multiple sequences in <tt class="docutils literal"><span class="pre">msq</span></tt>-format.</li>
<li>&#8220;html&#8221; &#8211; output of the multiple alignment in <tt class="docutils literal"><span class="pre">html</span></tt>-format.</li>
</ul>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>Select a specific name for the outfile, otherwise, the name of
the infile will be taken by default.</p>
</div></blockquote>
<p><strong>sorted_seqs</strong> : bool</p>
<blockquote>
<div><p>Indicate whether the sequences should be sorted or not (applys only
to &#8216;msa&#8217; and &#8216;msq&#8217; output.</p>
</div></blockquote>
<p><strong>unique_seqs</strong> : bool</p>
<blockquote class="last">
<div><p>Indicate whether only unique sequences should be written to file or
not.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingpy.align.sca.PSA">
<em class="property">class </em><tt class="descclassname">lingpy.align.sca.</tt><tt class="descname">PSA</tt><big>(</big><em>infile</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.PSA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.align.pairwise.Pairwise" title="lingpy.align.pairwise.Pairwise"><tt class="xref py py-class docutils literal"><span class="pre">lingpy.align.pairwise.Pairwise</span></tt></a></p>
<p>Basic class for dealing with the pairwise alignment of sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>infile</strong> : file</p>
<blockquote>
<div><p>A file in <tt class="docutils literal"><span class="pre">psq</span></tt>-format.</p>
</div></blockquote>
<p><strong>merge_vowels</strong> : bool (default=True)</p>
<blockquote>
<div><p>Indicate, whether neighboring vowels should be merged into
diphtongs, or whether they should be kept separated during the
analysis.</p>
</div></blockquote>
<p><strong>comment</strong> : char (default=&#8217;#&#8217;)</p>
<blockquote class="last">
<div><p>The comment character which, inserted in the beginning of a line,
prevents that line from being read.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In order to read in data from text files, two different file formats can be
used along with this class: the PSQ-format, and the PSA-format (see
<a class="reference internal" href="../tutorial/formats.html#psa-formats"><em>Pairwise Alignments (PSQ and PSA)</em></a> for details). This class inherits the methods of the
<a class="reference internal" href="#lingpy.align.pairwise.Pairwise" title="lingpy.align.pairwise.Pairwise"><tt class="xref py py-class docutils literal"><span class="pre">Pairwise</span></tt></a> class.</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="5%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>taxa</td>
<td>list</td>
<td>A list of tuples containing the taxa of all sequence pairs.</td>
</tr>
<tr class="row-even"><td>seqs</td>
<td>list</td>
<td>A list of tuples containing all sequence pairs.</td>
</tr>
<tr class="row-odd"><td>tokens</td>
<td>list</td>
<td>A list of tuples containing all sequence pairs in a tokenized form.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lingpy.align.sca.PSA.output">
<tt class="descname">output</tt><big>(</big><em>fileformat='psa'</em>, <em>filename=None</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.PSA.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the results of the analyses to a text file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileformat</strong> : { &#8216;psa&#8217;, &#8216;psq&#8217; }</p>
<blockquote>
<div><p>Indicate which data should be written to file. Select between:</p>
<ul class="simple">
<li>&#8216;psa&#8217; &#8211; output of all pairwise alignments in <tt class="docutils literal"><span class="pre">psa</span></tt>-format,</li>
<li>&#8216;psq&#8217; &#8211; output of the multiple sequences in <tt class="docutils literal"><span class="pre">psq</span></tt>-format.</li>
</ul>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote class="last">
<div><p>Select a specific name for the outfile, otherwise, the name of
the infile will be taken by default.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingpy.align.sca.SCA">
<tt class="descclassname">lingpy.align.sca.</tt><tt class="descname">SCA</tt><big>(</big><em>infile</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.SCA" title="Permalink to this definition">¶</a></dt>
<dd><p>Method returns alignment objects depending on input file or input data.</p>
<p class="rubric">Notes</p>
<p>This method checks for the type of an alignment object and returns an
alignment object of the respective type.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.sca.get_consensus">
<tt class="descclassname">lingpy.align.sca.</tt><tt class="descname">get_consensus</tt><big>(</big><em>msa</em>, <em>tree=False</em>, <em>gaps=False</em>, <em>taxa=False</em>, <em>classes=False</em>, <em>**keywords</em><big>)</big><a class="headerlink" href="#lingpy.align.sca.get_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a consensus string of a given MSA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>msa</strong> : {c{list} ~lingpy.align.multiple.Multiple}</p>
<blockquote>
<div><p>Either an MSA object or an MSA matrix.</p>
</div></blockquote>
<p><strong>tree</strong> : {c{str} ~lingpy.thirdparty.cogent.PhyloNode}</p>
<blockquote>
<div><p>A tree object or a Newick string along which the consensus shall be
calculated.</p>
</div></blockquote>
<p><strong>gaps</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return the gap positions in the consensus.</p>
</div></blockquote>
<p><strong>taxa</strong> : {c{list} bool} (default=False)</p>
<blockquote>
<div><p>If <em>tree</em> is chosen as a parameter, specify the taxa in order of the aligned
strings.</p>
</div></blockquote>
<p><strong>classes</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>Specify whether sound classes shall be used to calculate the consensus.</p>
</div></blockquote>
<p><strong>model</strong> : ~lingpy.data.model.Model</p>
<blockquote>
<div><p>A sound class model according to which the IPA strings shall be
converted to sound-class strings.</p>
</div></blockquote>
<p><strong>local</strong> : { c{bool}, &#8220;peaks&#8221;, &#8220;gaps&#8221; }(default=False)</p>
<blockquote>
<div><p>Specify whether local pre-processing should be applied to the data. If
set to c{peaks}, the average alignment score of each column is taken as
reference to remove low-scoring columns from the alignment. If set to
&#8220;gaps&#8221;, the columns with the highest proportion of gaps will be
excluded.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cons</strong> : c{str}</p>
<blockquote class="last">
<div><p>A consensus string of the given MSA.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/lingpy-logo.svg" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">align Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">align</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-lingpy.align.multiple"><tt class="docutils literal"><span class="pre">multiple</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-lingpy.align.pairwise"><tt class="docutils literal"><span class="pre">pairwise</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-lingpy.align.sca"><tt class="docutils literal"><span class="pre">sca</span></tt> Module</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/reference/lingpy.align.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>
 <div id="footer">
   <div class="fleft">
     <a href="http://www.hhu.de/"><img width="120px" src="http://www.hhu.de/home/fileadmin/images/uni_duesseldorf_logo.gif" alt="HHUD" /></a>
   </div>
  <div class="fleft">
    <a href="http://www.uni-marburg.de/"><img width="120px" src="http://www.uni-marburg.de/bilder/logo_uni1.gif" alt="PUD" /></a>
  </div>


  <div class="fcenter">
    <p style="font-size:70%">Created using <a href="http://sphinx-doc.org">Sphinx</a>. Last updated on June 5, 2014.<br>
      This work is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">Creative
      Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
        <img alt="Creative Commons License" style="border-width:0;width:100px;"
		    src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a> </p>
  </div>

  <div class="fright">
    <a href="http://www.bmbf.de/"><img width="100px" src="http://www.bmbf.de/_img/common/BMBF_Logo.png" alt="BMBF" /></a>
 </div>
  <div class="fright">
    <a href="http://erc.europa.eu/"><img width="80px" src="http://quanthistling.info/theme/qhl/images/logo_erc.png" alt="ERC" /></a>
  </div>
  <div class="fright">
    <a href="http://www.uni-tuebingen.de"><img width="120px" src="http://www.uni-tuebingen.de/fileadmin/pics/logo-uni-tuebingen.png" alt="logo_tuebingen" /></a>
</div>
</div>

  </body>
</html>