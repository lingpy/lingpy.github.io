<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cogent Package &mdash; LingPy</title>
    
    <link rel="stylesheet" href="../_static/lingpy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="top" title="LingPy" href="../index.html" />
<link rel="stylesheet" type="text/css" href="_static/handheld.css" media="screen and (max-device-width: 720px)" />

  </head>
  <body>
<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
LingPy
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>

<br/><p>This documentation is for version <b>2.4.dev</b>, which is
  not released yet.</p>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cogent-package">
<h1>cogent Package<a class="headerlink" href="#cogent-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">cogent</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-lingpy.thirdparty.cogent"></span><p>Simple py3-port of PyCogent&#8217;s (<a class="reference external" href="http://pycogent.sourceforge.net">http://pycogent.sourceforge.net</a>) Tree classes.</p>
</div>
<div class="section" id="module-lingpy.thirdparty.cogent.newick">
<span id="newick-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">newick</span></tt> Module<a class="headerlink" href="#module-lingpy.thirdparty.cogent.newick" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Newick format with all features as per the specs at:</dt>
<dd><a class="reference external" href="http://evolution.genetics.washington.edu/phylip/newick_doc.html">http://evolution.genetics.washington.edu/phylip/newick_doc.html</a>
<a class="reference external" href="http://evolution.genetics.washington.edu/phylip/newicktree.html">http://evolution.genetics.washington.edu/phylip/newicktree.html</a></dd>
<dt>ie:</dt>
<dd>Unquoted label underscore munging
Quoted labels
Inner node labels
Lengths
[ ... ] Comments (discarded)
Unlabeled tips</dd>
<dt>also:</dt>
<dd>Double quotes can be used.
Spaces and quote marks are OK inside unquoted labels.</dd>
</dl>
<dl class="exception">
<dt id="lingpy.thirdparty.cogent.newick.TreeParseError">
<em class="property">exception </em><tt class="descclassname">lingpy.thirdparty.cogent.newick.</tt><tt class="descname">TreeParseError</tt><a class="headerlink" href="#lingpy.thirdparty.cogent.newick.TreeParseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.ValueError</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="lingpy.thirdparty.cogent.newick.parse_string">
<tt class="descclassname">lingpy.thirdparty.cogent.newick.</tt><tt class="descname">parse_string</tt><big>(</big><em>text</em>, <em>constructor</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.newick.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a Newick-format string, using specified constructor for tree.</p>
<p>Calls constructor(children, name, attributes)</p>
<p>Note: underscore_unmunge, if True, replaces underscores with spaces in
the data that&#8217;s read in. This is part of the Newick format, but it is
often useful to suppress this behavior.</p>
</dd></dl>

</div>
<div class="section" id="module-lingpy.thirdparty.cogent.tree">
<span id="tree-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">tree</span></tt> Module<a class="headerlink" href="#module-lingpy.thirdparty.cogent.tree" title="Permalink to this headline">¶</a></h2>
<p>Classes for storing and manipulating a phylogenetic tree.</p>
<p>These trees can be either strictly binary, or have polytomies
(multiple children to a parent node).</p>
<p>Trees consist of Nodes (or branches) that connect two nodes. The Tree can
be created only from a newick formatted string read either from file or from a
string object. Other formats will be added as time permits.</p>
<dl class="docutils">
<dt>Tree can:</dt>
<dd><ul class="first last simple">
<li>Deal with either rooted or unrooted tree&#8217;s and can
convert between these types.</li>
<li>Return a sub-tree given a list of tip-names</li>
<li>Identify an edge given two tip names. This method facilitates the
statistical modelling by simplyifying the syntax for specifying
sub-regions of a tree.</li>
<li>Assess whether two Tree instances represent the same topology.</li>
</ul>
</dd>
<dt>Definition of relevant terms or abbreviations:</dt>
<dd><ul class="first last simple">
<li>edge: also known as a branch on a tree.</li>
<li>node: the point at which two edges meet</li>
<li>tip: a sequence or species</li>
<li>clade: all and only the nodes (including tips) that descend
from a node</li>
<li>stem: the edge immediately preceeding a clade</li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="lingpy.thirdparty.cogent.tree.LoadTree">
<tt class="descclassname">lingpy.thirdparty.cogent.tree.</tt><tt class="descname">LoadTree</tt><big>(</big><em>filename=None</em>, <em>treestring=None</em>, <em>tip_names=None</em>, <em>underscore_unmunge=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.LoadTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for tree.</p>
<dl class="docutils">
<dt>Arguments, use only one of:</dt>
<dd><ul class="first last simple">
<li>filename: a file containing a newick or xml formatted tree.</li>
<li>treestring: a newick or xml formatted tree string.</li>
<li>tip_names: a list of tip names.</li>
</ul>
</dd>
</dl>
<p>Note: underscore_unmunging is turned off by default, although it is part
of the Newick format. Set underscore_unmunge to True to replace underscores
with spaces in all names read.</p>
</dd></dl>

<dl class="class">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode">
<em class="property">class </em><tt class="descclassname">lingpy.thirdparty.cogent.tree.</tt><tt class="descname">PhyloNode</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.thirdparty.cogent.tree.TreeNode" title="lingpy.thirdparty.cogent.tree.TreeNode"><tt class="xref py py-class docutils literal"><span class="pre">lingpy.thirdparty.cogent.tree.TreeNode</span></tt></a></p>
<dl class="attribute">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.Length">
<tt class="descname">Length</tt><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.Length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.balanced">
<tt class="descname">balanced</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.balanced" title="Permalink to this definition">¶</a></dt>
<dd><p>Tree &#8216;rooted&#8217; here with no neighbour having &gt; 50% of the edges.</p>
<dl class="docutils">
<dt>Usage:</dt>
<dd>Using a balanced tree can substantially improve performance of
the likelihood calculations. Note that the resulting tree has a
different orientation with the effect that specifying clades or
stems for model parameterisation should be done using the
&#8216;outgroup_name&#8217; argument.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.bifurcating">
<tt class="descname">bifurcating</tt><big>(</big><em>constructor=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.bifurcating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.compareByPartitions">
<tt class="descname">compareByPartitions</tt><big>(</big><em>other</em>, <em>debug=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.compareByPartitions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.distance">
<tt class="descname">distance</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns branch length between self and other.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.getDistances">
<tt class="descname">getDistances</tt><big>(</big><em>endpoints=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.getDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>The distance matrix as a dictionary.</p>
<dl class="docutils">
<dt>Usage:</dt>
<dd>Grabs the branch lengths (evolutionary distances) as
a complete matrix (i.e. a,b and b,a).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.getNewick">
<tt class="descname">getNewick</tt><big>(</big><em>with_distances=False</em>, <em>semicolon=True</em>, <em>escape_name=True</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.getNewick" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.prune">
<tt class="descname">prune</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs correct tree after nodes have been removed.</p>
<p>Internal nodes with only one child will be removed and new connections
and Branch lengths will be made to reflect change.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.rootAtMidpoint">
<tt class="descname">rootAtMidpoint</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.rootAtMidpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>return a new tree rooted at midpoint of the two tips farthest apart</p>
<p>this fn doesn&#8217;t preserve the internal node naming or structure,
but does keep tip to tip distances correct.  uses unrootedDeepcopy()</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.rootedAt">
<tt class="descname">rootedAt</tt><big>(</big><em>edge_name</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.rootedAt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new tree rooted at the provided node.</p>
<dl class="docutils">
<dt>Usage:</dt>
<dd>This can be useful for drawing unrooted trees with an orientation
that reflects knowledge of the true root location.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.rootedWithTip">
<tt class="descname">rootedWithTip</tt><big>(</big><em>outgroup_name</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.rootedWithTip" title="Permalink to this definition">¶</a></dt>
<dd><p>A new tree with the named tip as one of the root&#8217;s children</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.sameTopology">
<tt class="descname">sameTopology</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.sameTopology" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether two trees have the same topology.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.scaleBranchLengths">
<tt class="descname">scaleBranchLengths</tt><big>(</big><em>max_length=100</em>, <em>ultrametric=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.scaleBranchLengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Scales BranchLengths in place to integers for ascii output.</p>
<p>Warning: tree might not be exactly the length you specify.</p>
<p>Set ultrametric=True if you want all the root-tip distances to end
up precisely the same.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.setTipDistances">
<tt class="descname">setTipDistances</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.setTipDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets distance from each node to the most distant tip.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.tipToTipDistances">
<tt class="descname">tipToTipDistances</tt><big>(</big><em>endpoints=None</em>, <em>default_length=1</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.tipToTipDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns distance matrix between all pairs of tips, and a tip order.</p>
<p>Warning: .__start and .__stop added to self and its descendants.</p>
<p>tip_order contains the actual node objects, not their names (may be
confusing in some cases).</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.tipsWithinDistance">
<tt class="descname">tipsWithinDistance</tt><big>(</big><em>distance</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.tipsWithinDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns tips within specified distance from self</p>
<p>Branch lengths of None will be interpreted as 0</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.totalDescendingBranchLength">
<tt class="descname">totalDescendingBranchLength</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.totalDescendingBranchLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns total descending branch length from self</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.unrooted">
<tt class="descname">unrooted</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.unrooted" title="Permalink to this definition">¶</a></dt>
<dd><p>A tree with at least 3 children at the root.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.unrootedDeepcopy">
<tt class="descname">unrootedDeepcopy</tt><big>(</big><em>constructor=None</em>, <em>parent=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.unrootedDeepcopy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingpy.thirdparty.cogent.tree.TreeBuilder">
<em class="property">class </em><tt class="descclassname">lingpy.thirdparty.cogent.tree.</tt><tt class="descname">TreeBuilder</tt><big>(</big><em>mutable=False</em>, <em>constructor=&lt;class 'lingpy.thirdparty.cogent.tree.PhyloNode'&gt;</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeBuilder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeBuilder.createEdge">
<tt class="descname">createEdge</tt><big>(</big><em>children</em>, <em>name</em>, <em>params</em>, <em>nameLoaded=True</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeBuilder.createEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for newick parser</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeBuilder.edgeFromEdge">
<tt class="descname">edgeFromEdge</tt><big>(</big><em>edge</em>, <em>children</em>, <em>params=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeBuilder.edgeFromEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for tree-to-tree transforms like getSubTree</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="lingpy.thirdparty.cogent.tree.TreeError">
<em class="property">exception </em><tt class="descclassname">lingpy.thirdparty.cogent.tree.</tt><tt class="descname">TreeError</tt><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.Exception</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode">
<em class="property">class </em><tt class="descclassname">lingpy.thirdparty.cogent.tree.</tt><tt class="descname">TreeNode</tt><big>(</big><em>Name=None</em>, <em>Children=None</em>, <em>Parent=None</em>, <em>Params=None</em>, <em>NameLoaded=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Store information about a tree node. Mutable.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd>Name: label for the node, assumed to be unique.
Children: list of the node&#8217;s children.
Params: dict containing arbitrary parameters for the node.
NameLoaded: ?</dd>
</dl>
<dl class="attribute">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.Parent">
<tt class="descname">Parent</tt><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.Parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor for parent.</p>
<p>If using an algorithm that accesses Parent a lot, it will be much
faster to access self._parent directly, but don&#8217;t do it if mutating
self._parent! (or, if you must, remember to clean up the refs).</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.ancestors">
<tt class="descname">ancestors</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.ancestors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all ancestors back to the root. Dynamically calculated.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.append">
<tt class="descname">append</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends i to self.Children, in-place, cleaning up refs.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.asciiArt">
<tt class="descname">asciiArt</tt><big>(</big><em>show_internal=True</em>, <em>compact=False</em>, <em>labels=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.asciiArt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string containing an ascii drawing of the tree.</p>
<p>Arguments:
- show_internal: includes internal edge names.
- compact: use exactly one line per tip.
- labels: specify specific labels for all nodes in the tree.</p>
<p>Notes:
The labels-keyword was added to the function by JML.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.childGroups">
<tt class="descname">childGroups</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.childGroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list containing lists of children sharing a state.</p>
<p>In other words, returns runs of tip and nontip children.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.compareByNames">
<tt class="descname">compareByNames</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.compareByNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Equality test for trees by name</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.compareBySubsets">
<tt class="descname">compareBySubsets</tt><big>(</big><em>other</em>, <em>exclude_absent_taxa=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.compareBySubsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns fraction of overlapping subsets where self and other differ.</p>
<p>Other is expected to be a tree object compatible with PhyloNode.</p>
<p>Note: names present in only one of the two trees will count as 
mismatches: if you don&#8217;t want this behavior, strip out the non-matching
tips first.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.compareName">
<tt class="descname">compareName</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.compareName" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares TreeNode by name</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.copy">
<tt class="descname">copy</tt><big>(</big><em>memo=None</em>, <em>_nil=[]</em>, <em>constructor='ignored'</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of self using an iterative approach</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.copyRecursive">
<tt class="descname">copyRecursive</tt><big>(</big><em>memo=None</em>, <em>_nil=[]</em>, <em>constructor='ignored'</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.copyRecursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns copy of self&#8217;s structure, including shallow copy of attrs.</p>
<p>constructor is ignored; required to support old tree unit tests.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.copyTopology">
<tt class="descname">copyTopology</tt><big>(</big><em>constructor=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.copyTopology" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies only the topology and labels of a tree, not any extra data.</p>
<p>Useful when you want another copy of the tree with the same structure
and labels, but want to e.g. assign different branch lengths and
environments. Does not use deepcopy from the copy module, so _much_
faster than the copy() method.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.deepcopy">
<tt class="descname">deepcopy</tt><big>(</big><em>memo=None</em>, <em>_nil=[]</em>, <em>constructor='ignored'</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of self using an iterative approach</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.descendantArray">
<tt class="descname">descendantArray</tt><big>(</big><em>tip_list=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.descendantArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns numpy array with nodes in rows and descendants in columns.</p>
<p>A value of 1 indicates that the decendant is a descendant of that node/
A value of 0 indicates that it is not</p>
<p>Also returns a list of nodes in the same order as they are listed
in the array.</p>
<p>tip_list is a list of the names of the tips that will be considered,
in the order they will appear as columns in the final array. Internal
nodes will appear as rows in preorder traversal order.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.extend">
<tt class="descname">extend</tt><big>(</big><em>items</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends self.Children by items, in-place, cleaning up refs.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getConnectingEdges">
<tt class="descname">getConnectingEdges</tt><big>(</big><em>name1</em>, <em>name2</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getConnectingEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of edges connecting two nodes</p>
<p>includes self and other in the list</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getConnectingNode">
<tt class="descname">getConnectingNode</tt><big>(</big><em>name1</em>, <em>name2</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getConnectingNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the last common ancestor of the two named edges.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getDistances">
<tt class="descname">getDistances</tt><big>(</big><em>endpoints=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>The distance matrix as a dictionary.</p>
<dl class="docutils">
<dt>Usage:</dt>
<dd>Grabs the branch lengths (evolutionary distances) as
a complete matrix (i.e. a,b and b,a).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getEdgeNames">
<tt class="descname">getEdgeNames</tt><big>(</big><em>tip1name</em>, <em>tip2name</em>, <em>getclade</em>, <em>getstem</em>, <em>outgroup_name=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getEdgeNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of stem and/or sub tree (clade) edge name(s).
This is done by finding the common intersection, and then getting
the list of names. If the clade traverses the root, then use the
outgroup_name argument to ensure valid specification.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><ul class="first last simple">
<li>tip1/2name: edge 1/2 names</li>
<li>getstem: whether the name of the clade stem edge is returned.</li>
<li>getclade: whether the names of the edges within the clade are
returned</li>
<li>outgroup_name: if provided the calculation is done on a version of
the tree re-rooted relative to the provided tip.</li>
</ul>
</dd>
<dt>Usage:</dt>
<dd>The returned list can be used to specify subtrees for special
parameterisation. For instance, say you want to allow the primates
to have a different value of a particular parameter. In this case,
provide the results of this method to the parameter controller
method <cite>setParamRule()</cite> along with the parameter name etc..</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getEdgeVector">
<tt class="descname">getEdgeVector</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getEdgeVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect the list of edges in postfix order</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getMaxTipTipDistance">
<tt class="descname">getMaxTipTipDistance</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getMaxTipTipDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the max tip tip distance between any pair of tips</p>
<p>Returns (dist, tip_names, internal_node)</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getNewick">
<tt class="descname">getNewick</tt><big>(</big><em>with_distances=False</em>, <em>semicolon=True</em>, <em>escape_name=True</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getNewick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the newick string for this tree.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><ul class="first last">
<li><p class="first">with_distances: whether branch lengths are included.</p>
</li>
<li><p class="first">semicolon: end tree string with a semicolon</p>
</li>
<li><dl class="first docutils">
<dt>escape_name: if any of these characters []&#8217;&#8221;(),:;_ exist in a</dt>
<dd><p class="first last">nodes name, wrap the name in single quotes</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>NOTE: This method returns the Newick representation of this node
and its descendents. This method is a modification of an implementation
by Zongzhi Liu</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getNewickRecursive">
<tt class="descname">getNewickRecursive</tt><big>(</big><em>with_distances=False</em>, <em>semicolon=True</em>, <em>escape_name=True</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getNewickRecursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the newick string for this edge.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><ul class="first last">
<li><p class="first">with_distances: whether branch lengths are included.</p>
</li>
<li><p class="first">semicolon: end tree string with a semicolon</p>
</li>
<li><dl class="first docutils">
<dt>escape_name: if any of these characters []&#8217;&#8221;(),:;_ exist in a</dt>
<dd><p class="first last">nodes name, wrap the name in single quotes</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getNodeMatchingName">
<tt class="descname">getNodeMatchingName</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getNodeMatchingName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getNodeNames">
<tt class="descname">getNodeNames</tt><big>(</big><em>includeself=True</em>, <em>tipsonly=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getNodeNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of edges from this edge - may or may not include self.
This node (or first connection) will be the first, and then they will
be listed in the natural traverse order.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getNodesDict">
<tt class="descname">getNodesDict</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getNodesDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dict keyed by node name, value is node</p>
<p>Will raise TreeError if non-unique names are encountered</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getParamValue">
<tt class="descname">getParamValue</tt><big>(</big><em>param</em>, <em>edge</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getParamValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the parameter value for named edge</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getSubTree">
<tt class="descname">getSubTree</tt><big>(</big><em>name_list</em>, <em>ignore_missing=False</em>, <em>keep_root=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getSubTree" title="Permalink to this definition">¶</a></dt>
<dd><p>A new instance of a sub tree that contains all the otus that are
listed in name_list.</p>
<p>ignore_missing: if False, getSubTree will raise a ValueError if 
name_list contains names that aren&#8217;t nodes in the tree</p>
<p>keep_root: if False, the root of the subtree will be the last common
ancestor of all nodes kept in the subtree. Root to tip distance is
then (possibly) different from the original tree
If True, the root to tip distance remains constant, but root may only
have one child node.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getTipNames">
<tt class="descname">getTipNames</tt><big>(</big><em>includeself=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getTipNames" title="Permalink to this definition">¶</a></dt>
<dd><p>return the list of the names of all tips contained by this edge</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getXML">
<tt class="descname">getXML</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getXML" title="Permalink to this definition">¶</a></dt>
<dd><p>Return XML formatted tree string.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.get_LCA">
<tt class="descname">get_LCA</tt><big>(</big><em>*nodes</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.get_LCA" title="Permalink to this definition">¶</a></dt>
<dd><p>Find lowest common ancestor of a given number of nodes.</p>
<p class="rubric">Notes</p>
<p>This function is supposed to yield the same output as
lowestCommonAncestor does. It was added in order to overcome certain
problems in the original function, resulting from attributes added to a
PhyloNode-object that make the use at time unsecure. Furthermore, it
works with an arbitrary list of nodes (including tips and internal
nodes).</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.indexInParent">
<tt class="descname">indexInParent</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.indexInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns index of self in parent.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.insert">
<tt class="descname">insert</tt><big>(</big><em>index</em>, <em>i</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts an item at specified position in self.Children.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.isRoot">
<tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the current is a root, i.e. has no parent.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.isTip">
<tt class="descname">isTip</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.isTip" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the current node is a tip, i.e. has no children.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.isroot">
<tt class="descname">isroot</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.isroot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if root of a tree, i.e. no parent.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.istip">
<tt class="descname">istip</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.istip" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if is tip, i.e. no children.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.iterNontips">
<tt class="descname">iterNontips</tt><big>(</big><em>include_self=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.iterNontips" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over nontips descended from self, [] if none.</p>
<p>include_self, if True (default is False), will return the current
node as part of the list of nontips if it is a nontip.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.iterTips">
<tt class="descname">iterTips</tt><big>(</big><em>include_self=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.iterTips" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over tips descended from self, [] if self is a tip.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.lastCommonAncestor">
<tt class="descname">lastCommonAncestor</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.lastCommonAncestor" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds last common ancestor of self and other, or None.</p>
<p>Always tests by identity.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.lca">
<tt class="descname">lca</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.lca" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds last common ancestor of self and other, or None.</p>
<p>Always tests by identity.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.levelorder">
<tt class="descname">levelorder</tt><big>(</big><em>include_self=True</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.levelorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs levelorder iteration over tree</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.lowestCommonAncestor">
<tt class="descname">lowestCommonAncestor</tt><big>(</big><em>tipnames</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.lowestCommonAncestor" title="Permalink to this definition">¶</a></dt>
<dd><p>Lowest common ancestor for a list of tipnames</p>
<p>This should be around O(H sqrt(n)), where H is height and n is the
number of tips passed in.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.makeTreeArray">
<tt class="descname">makeTreeArray</tt><big>(</big><em>dec_list=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.makeTreeArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes an array with nodes in rows and descendants in columns.</p>
<p>A value of 1 indicates that the decendant is a descendant of that node/
A value of 0 indicates that it is not</p>
<p>also returns a list of nodes in the same order as they are listed
in the array</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.maxTipTipDistance">
<tt class="descname">maxTipTipDistance</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.maxTipTipDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the max distance between any pair of tips</p>
<p>Also returns the tip names  that it is between as a tuple</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.nameUnnamedNodes">
<tt class="descname">nameUnnamedNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.nameUnnamedNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the Data property of unnamed nodes to an arbitrary value</p>
<p>Internal nodes are often unnamed and so this function assigns a
value for referencing.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.nonTipChildren">
<tt class="descname">nonTipChildren</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.nonTipChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns direct children in self that have descendants.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.nontips">
<tt class="descname">nontips</tt><big>(</big><em>include_self=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.nontips" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns nontips descended from self.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.pop">
<tt class="descname">pop</tt><big>(</big><em>index=-1</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns and deletes child of self at index (default: -1)</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.postorder">
<tt class="descname">postorder</tt><big>(</big><em>include_self=True</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.postorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs postorder iteration over tree.</p>
<p>This is somewhat inelegant compared to saving the node and its index
on the stack, but is 30% faster in the average case and 3x faster in
the worst case (for a comb tree).</p>
<p>Zongzhi Liu&#8217;s slower but more compact version is:</p>
<dl class="docutils">
<dt>def postorder_zongzhi(self):</dt>
<dd><p class="first">stack = [[self, 0]]
while stack:</p>
<blockquote class="last">
<div><p>curr, child_idx = stack[-1]
if child_idx &lt; len(curr.Children):</p>
<blockquote>
<div>stack[-1][1] += 1
stack.append([curr.Children[child_idx], 0])</div></blockquote>
<dl class="docutils">
<dt>else:</dt>
<dd>yield stack.pop()[0]</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.pre_and_postorder">
<tt class="descname">pre_and_postorder</tt><big>(</big><em>include_self=True</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.pre_and_postorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs iteration over tree, visiting node before and after.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.preorder">
<tt class="descname">preorder</tt><big>(</big><em>include_self=True</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.preorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs preorder iteration over tree.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.prune">
<tt class="descname">prune</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs correct topology after nodes have been removed.</p>
<p>Internal nodes with only one child will be removed and new connections
will be made to reflect change.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.reassignNames">
<tt class="descname">reassignNames</tt><big>(</big><em>mapping</em>, <em>nodes=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.reassignNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Reassigns node names based on a mapping dict</p>
<p>mapping : dict, old_name -&gt; new_name
nodes : specific nodes for renaming (such as just tips, etc...)</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.remove">
<tt class="descname">remove</tt><big>(</big><em>target</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes node by name instead of identity.</p>
<p>Returns True if node was present, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.removeDeleted">
<tt class="descname">removeDeleted</tt><big>(</big><em>is_deleted</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.removeDeleted" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all nodes where is_deleted tests true.</p>
<p>Internal nodes that have no children as a result of removing deleted
are also removed.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.removeNode">
<tt class="descname">removeNode</tt><big>(</big><em>target</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.removeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes node by identity instead of value.</p>
<p>Returns True if node was present, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.root">
<tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.root" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns root of the tree self is in. Dynamically calculated.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.sameShape">
<tt class="descname">sameShape</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.sameShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Ignores lengths and order, so trees should be sorted first</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.separation">
<tt class="descname">separation</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.separation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of edges separating self and other.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.setMaxTipTipDistance">
<tt class="descname">setMaxTipTipDistance</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.setMaxTipTipDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate tip distance information up the tree</p>
<p>This method was originally implemented by Julia Goodrich with the intent
of being able to determine max tip to tip distances between nodes on 
large trees efficiently. The code has been modified to track the 
specific tips the distance is between</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.setParamValue">
<tt class="descname">setParamValue</tt><big>(</big><em>param</em>, <em>edge</em>, <em>value</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.setParamValue" title="Permalink to this definition">¶</a></dt>
<dd><p>set&#8217;s the value for param at named edge</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.siblings">
<tt class="descname">siblings</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.siblings" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all nodes that are children of the same parent as self.</p>
<p>Note: excludes self from the list. Dynamically calculated.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.sorted">
<tt class="descname">sorted</tt><big>(</big><em>sort_order=[]</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>An equivalent tree sorted into a standard order. If this is not
specified then alphabetical order is used.  At each node starting from
root, the algorithm will try to put the descendant which contains the
lowest scoring tip on the left.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.subset">
<tt class="descname">subset</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns set of names that descend from specified node</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.subsets">
<tt class="descname">subsets</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.subsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all sets of names that come from specified node and its kids</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.tipChildren">
<tt class="descname">tipChildren</tt><big>(</big><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.tipChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns direct children of self that are tips.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.tipToTipDistances">
<tt class="descname">tipToTipDistances</tt><big>(</big><em>default_length=1</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.tipToTipDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns distance matrix between all pairs of tips, and a tip order.</p>
<p>Warning: .__start and .__stop added to self and its descendants.</p>
<p>tip_order contains the actual node objects, not their names (may be
confusing in some cases).</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.tips">
<tt class="descname">tips</tt><big>(</big><em>include_self=False</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.tips" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns tips descended from self, [] if self is a tip.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.traverse">
<tt class="descname">traverse</tt><big>(</big><em>self_before=True</em>, <em>self_after=False</em>, <em>include_self=True</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.traverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns iterator over descendants. Iterative: safe for large trees.</p>
<p>self_before includes each node before its descendants if True.
self_after includes each node after its descendants if True.
include_self includes the initial node if True.</p>
<p>self_before and self_after are independent. If neither is True, only
terminal nodes will be returned.</p>
<p>Note that if self is terminal, it will only be included once even if
self_before and self_after are both True.</p>
<p>This is a depth-first traversal. Since the trees are not binary,
preorder and postorder traversals are possible, but inorder traversals
would depend on the data in the tree and are not handled here.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.traverse_recursive">
<tt class="descname">traverse_recursive</tt><big>(</big><em>self_before=True</em>, <em>self_after=False</em>, <em>include_self=True</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.traverse_recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns iterator over descendants. IMPORTANT: read notes below.</p>
<p>traverse_recursive is slower than traverse, and can lead to stack
errors. However, you _must_ use traverse_recursive if you plan to
modify the tree topology as you walk over it (e.g. in post-order),
because the iterative methods use their own stack that is not updated
if you alter the tree.</p>
<p>self_before includes each node before its descendants if True.
self_after includes each node after its descendants if True.
include_self includes the initial node if True.</p>
<p>self_before and self_after are independent. If neither is True, only
terminal nodes will be returned.</p>
<p>Note that if self is terminal, it will only be included once even if
self_before and self_after are both True.</p>
<p>This is a depth-first traversal. Since the trees are not binary,
preorder and postorder traversals are possible, but inorder traversals
would depend on the data in the tree and are not handled here.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.writeToFile">
<tt class="descname">writeToFile</tt><big>(</big><em>filename</em>, <em>with_distances=True</em>, <em>format=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.writeToFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the tree to filename</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><ul class="first last simple">
<li>filename: self-evident</li>
<li>with_distances: whether branch lengths are included in string.</li>
<li>format: default is newick, xml is alternate. Argument overrides
the filename suffix. All attributes are saved in the xml format.</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingpy.thirdparty.cogent.tree.cmp">
<tt class="descclassname">lingpy.thirdparty.cogent.tree.</tt><tt class="descname">cmp</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.cmp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lingpy.thirdparty.cogent.tree.comb">
<tt class="descclassname">lingpy.thirdparty.cogent.tree.</tt><tt class="descname">comb</tt><big>(</big><em>items</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.comb" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields each successive combination of n items.</p>
<p>items: a slicable sequence.
n: number of items in each combination
This version from Raymond Hettinger, 2006/03/23</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/lingpy-logo.svg" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">cogent Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">cogent</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-lingpy.thirdparty.cogent.newick"><tt class="docutils literal"><span class="pre">newick</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-lingpy.thirdparty.cogent.tree"><tt class="docutils literal"><span class="pre">tree</span></tt> Module</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/reference/lingpy.thirdparty.cogent.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>
 <div id="footer">
   <div class="fleft">
     <a href="http://www.hhu.de/"><img width="120px" src="http://www.hhu.de/home/fileadmin/images/uni_duesseldorf_logo.gif" alt="HHUD" /></a>
   </div>
  <div class="fleft">
    <a href="http://www.uni-marburg.de/"><img width="120px" src="http://www.uni-marburg.de/bilder/logo_uni1.gif" alt="PUD" /></a>
  </div>


  <div class="fcenter">
    <p style="font-size:70%">Created using <a href="http://sphinx-doc.org">Sphinx</a>. Last updated on September 30, 2014.<br>
      This work is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">Creative
      Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
        <img alt="Creative Commons License" style="border-width:0;width:100px;"
		    src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a> </p>
  </div>

  <div class="fright">
    <a href="http://www.bmbf.de/"><img width="100px" src="http://www.bmbf.de/_img/common/BMBF_Logo.png" alt="BMBF" /></a>
 </div>
  <div class="fright">
    <a href="http://erc.europa.eu/"><img width="80px" src="http://quanthistling.info/theme/qhl/images/logo_erc.png" alt="ERC" /></a>
  </div>
  <div class="fright">
    <a href="http://www.uni-tuebingen.de"><img width="120px" src="http://www.uni-tuebingen.de/fileadmin/pics/logo-uni-tuebingen.png" alt="logo_tuebingen" /></a>
</div>
</div>

  </body>
</html>